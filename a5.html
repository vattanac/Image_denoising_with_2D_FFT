<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FFT Denoising Pipeline</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Rajdhani:wght@300;500;700&display=swap');

  :root {
    --bg: #060a14;
    --panel: #0b1120;
    --border: #1a2a4a;
    --accent: #ff4d00;
    --accent2: #00c9ff;
    --glow: #ff6b2b;
    --text: #c8d8f0;
    --dim: #4a6080;
    --mono: 'Share Tech Mono', monospace;
    --display: 'Rajdhani', sans-serif;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: var(--display);
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* Animated background grid */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background-image:
      linear-gradient(rgba(0,201,255,0.03) 1px, transparent 1px),
      linear-gradient(90deg, rgba(0,201,255,0.03) 1px, transparent 1px);
    background-size: 40px 40px;
    pointer-events: none;
    z-index: 0;
  }

  .wrapper {
    position: relative;
    z-index: 1;
    max-width: 1300px;
    margin: 0 auto;
    padding: 32px 24px;
  }

  /* Header */
  header {
    text-align: center;
    margin-bottom: 40px;
  }

  header .label {
    font-family: var(--mono);
    font-size: 11px;
    color: var(--accent2);
    letter-spacing: 4px;
    text-transform: uppercase;
    margin-bottom: 10px;
    opacity: 0.8;
  }

  header h1 {
    font-size: clamp(26px, 4vw, 46px);
    font-weight: 700;
    letter-spacing: 2px;
    background: linear-gradient(135deg, #fff 30%, var(--accent2));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    line-height: 1.1;
  }

  header p {
    margin-top: 10px;
    font-size: 14px;
    color: var(--dim);
    font-family: var(--mono);
  }

  /* Controls */
  .controls {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 32px;
    flex-wrap: wrap;
    margin-bottom: 36px;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 20px 32px;
  }

  .ctrl-group {
    display: flex;
    align-items: center;
    gap: 14px;
  }

  .ctrl-group label {
    font-family: var(--mono);
    font-size: 12px;
    color: var(--accent2);
    letter-spacing: 1px;
    white-space: nowrap;
  }

  input[type=range] {
    -webkit-appearance: none;
    width: 180px;
    height: 4px;
    background: var(--border);
    border-radius: 2px;
    outline: none;
    cursor: pointer;
  }
  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: var(--accent);
    box-shadow: 0 0 8px var(--glow);
    cursor: pointer;
    transition: box-shadow 0.2s;
  }
  input[type=range]:hover::-webkit-slider-thumb {
    box-shadow: 0 0 18px var(--glow);
  }

  .val-badge {
    font-family: var(--mono);
    font-size: 14px;
    color: var(--accent);
    min-width: 36px;
    text-align: right;
  }

  select {
    background: var(--bg);
    border: 1px solid var(--border);
    color: var(--text);
    font-family: var(--mono);
    font-size: 12px;
    padding: 6px 12px;
    border-radius: 6px;
    cursor: pointer;
    outline: none;
  }
  select:focus { border-color: var(--accent2); }

  .btn {
    font-family: var(--mono);
    font-size: 12px;
    letter-spacing: 1px;
    padding: 8px 20px;
    border-radius: 6px;
    border: 1px solid var(--accent);
    background: transparent;
    color: var(--accent);
    cursor: pointer;
    transition: all 0.2s;
  }
  .btn:hover {
    background: var(--accent);
    color: #000;
    box-shadow: 0 0 14px var(--glow);
  }

  /* Pipeline grid */
  .pipeline {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 20px;
    margin-bottom: 36px;
  }

  .stage {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    overflow: hidden;
    position: relative;
    transition: border-color 0.3s, box-shadow 0.3s;
  }

  .stage:hover {
    border-color: var(--accent2);
    box-shadow: 0 0 20px rgba(0,201,255,0.1);
  }

  .stage-header {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 14px;
    border-bottom: 1px solid var(--border);
  }

  .stage-num {
    font-family: var(--mono);
    font-size: 10px;
    color: var(--accent);
    background: rgba(255,77,0,0.1);
    border: 1px solid var(--accent);
    border-radius: 4px;
    padding: 2px 6px;
    line-height: 1;
  }

  .stage-title {
    font-size: 13px;
    font-weight: 500;
    letter-spacing: 1px;
    color: var(--text);
  }

  .stage-subtitle {
    margin-left: auto;
    font-family: var(--mono);
    font-size: 10px;
    color: var(--dim);
  }

  .stage canvas {
    display: block;
    width: 100%;
    aspect-ratio: 1;
    image-rendering: pixelated;
  }

  /* PSNR bar */
  .metrics {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 20px 28px;
    display: flex;
    align-items: center;
    gap: 40px;
    flex-wrap: wrap;
  }

  .metric {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .metric-label {
    font-family: var(--mono);
    font-size: 10px;
    color: var(--dim);
    letter-spacing: 1px;
    text-transform: uppercase;
  }

  .metric-val {
    font-family: var(--mono);
    font-size: 24px;
    font-weight: 700;
    color: var(--accent2);
    letter-spacing: 1px;
  }

  .psnr-bar-wrap {
    flex: 1;
    min-width: 200px;
  }

  .psnr-bar-track {
    height: 8px;
    background: var(--border);
    border-radius: 4px;
    overflow: hidden;
    margin-top: 8px;
  }

  .psnr-bar-fill {
    height: 100%;
    border-radius: 4px;
    background: linear-gradient(90deg, var(--accent), var(--accent2));
    transition: width 0.4s ease;
    box-shadow: 0 0 8px var(--accent2);
  }

  .arrow-row {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    font-family: var(--mono);
    font-size: 11px;
    color: var(--dim);
    margin: -6px 0 6px;
    letter-spacing: 2px;
  }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to   { opacity: 1; transform: translateY(0); }
  }

  .stage { animation: fadeIn 0.5s ease both; }
  .stage:nth-child(1) { animation-delay: 0.05s; }
  .stage:nth-child(2) { animation-delay: 0.10s; }
  .stage:nth-child(3) { animation-delay: 0.15s; }
  .stage:nth-child(4) { animation-delay: 0.20s; }
  .stage:nth-child(5) { animation-delay: 0.25s; }
  .stage:nth-child(6) { animation-delay: 0.30s; }

  @media (max-width: 800px) {
    .pipeline { grid-template-columns: repeat(2, 1fr); }
  }
  @media (max-width: 520px) {
    .pipeline { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>
<div class="wrapper">

  <header>
    <div class="label">Signal Processing Visualization</div>
    <h1>FFT Denoising Pipeline</h1>
    <p>noisy input → FFT → Gaussian filter → inverse FFT → clean output</p>
  </header>

  <div class="controls">
    <div class="ctrl-group">
      <label>CUTOFF FREQ</label>
      <input type="range" id="cutoff" min="5" max="120" value="50">
      <span class="val-badge" id="cutoffVal">50</span>
    </div>
    <div class="ctrl-group">
      <label>NOISE LEVEL</label>
      <input type="range" id="noise" min="0" max="80" value="40">
      <span class="val-badge" id="noiseVal">40</span>
    </div>
    <div class="ctrl-group">
      <label>SCENE</label>
      <select id="scene">
        <option value="geometric">Geometric</option>
        <option value="circles">Circles</option>
        <option value="lines">Lines</option>
        <option value="checkerboard">Checkerboard</option>
      </select>
    </div>
    <button class="btn" id="runBtn">▶ RUN PIPELINE</button>
  </div>

  <div class="pipeline">
    <div class="stage">
      <div class="stage-header">
        <span class="stage-num">01</span>
        <span class="stage-title">NOISY INPUT</span>
        <span class="stage-subtitle">spatial domain</span>
      </div>
      <canvas id="c1" width="256" height="256"></canvas>
    </div>
    <div class="stage">
      <div class="stage-header">
        <span class="stage-num">02</span>
        <span class="stage-title">FFT SPECTRUM</span>
        <span class="stage-subtitle">log magnitude</span>
      </div>
      <canvas id="c2" width="256" height="256"></canvas>
    </div>
    <div class="stage">
      <div class="stage-header">
        <span class="stage-num">03</span>
        <span class="stage-title">GAUSSIAN FILTER</span>
        <span class="stage-subtitle">low-pass mask</span>
      </div>
      <canvas id="c3" width="256" height="256"></canvas>
    </div>
    <div class="stage">
      <div class="stage-header">
        <span class="stage-num">04</span>
        <span class="stage-title">FILTERED SPECTRUM</span>
        <span class="stage-subtitle">masked FFT</span>
      </div>
      <canvas id="c4" width="256" height="256"></canvas>
    </div>
    <div class="stage">
      <div class="stage-header">
        <span class="stage-num">05</span>
        <span class="stage-title">DENOISED OUTPUT</span>
        <span class="stage-subtitle" id="psnrLabel">PSNR: —</span>
      </div>
      <canvas id="c5" width="256" height="256"></canvas>
    </div>
    <div class="stage">
      <div class="stage-header">
        <span class="stage-num">06</span>
        <span class="stage-title">ORIGINAL REFERENCE</span>
        <span class="stage-subtitle">ground truth</span>
      </div>
      <canvas id="c6" width="256" height="256"></canvas>
    </div>
  </div>

  <div class="metrics">
    <div class="metric">
      <div class="metric-label">PSNR</div>
      <div class="metric-val" id="mPSNR">—</div>
    </div>
    <div class="metric">
      <div class="metric-label">MSE</div>
      <div class="metric-val" id="mMSE">—</div>
    </div>
    <div class="metric">
      <div class="metric-label">Cutoff</div>
      <div class="metric-val" id="mCutoff">50</div>
    </div>
    <div class="metric">
      <div class="metric-label">Noise σ</div>
      <div class="metric-val" id="mNoise">40</div>
    </div>
    <div class="psnr-bar-wrap">
      <div class="metric-label">SIGNAL QUALITY</div>
      <div class="psnr-bar-track">
        <div class="psnr-bar-fill" id="psnrBar" style="width:0%"></div>
      </div>
    </div>
  </div>

</div>

<script>
// ─── Utility ──────────────────────────────────────────────────────────────────
const N = 256;

function clamp(v,lo,hi){ return Math.max(lo,Math.min(hi,v)); }

// Simple DFT via the Cooley-Tukey FFT (radix-2 in-place)
// We operate on a flat Float32Array of length N*N (real-only → complex)

function fft1d(re, im, invert) {
  const n = re.length;
  // Bit-reversal permutation
  for (let i=1,j=0; i<n; i++) {
    let bit = n>>1;
    for (; j&bit; bit>>=1) j^=bit;
    j^=bit;
    if (i<j) {
      [re[i],re[j]]=[re[j],re[i]];
      [im[i],im[j]]=[im[j],im[i]];
    }
  }
  for (let len=2; len<=n; len<<=1) {
    const ang = 2*Math.PI/len*(invert?-1:1);
    const wre=Math.cos(ang), wim=Math.sin(ang);
    for (let i=0; i<n; i+=len) {
      let cur_re=1, cur_im=0;
      for (let j=0; j<len/2; j++) {
        const u_re=re[i+j], u_im=im[i+j];
        const v_re=re[i+j+len/2]*cur_re - im[i+j+len/2]*cur_im;
        const v_im=re[i+j+len/2]*cur_im + im[i+j+len/2]*cur_re;
        re[i+j]=u_re+v_re; im[i+j]=u_im+v_im;
        re[i+j+len/2]=u_re-v_re; im[i+j+len/2]=u_im-v_im;
        const nr=cur_re*wre-cur_im*wim;
        cur_im=cur_re*wim+cur_im*wre;
        cur_re=nr;
      }
    }
  }
  if (invert) { for(let i=0;i<n;i++){re[i]/=n;im[i]/=n;} }
}

function fft2d(re, im, invert) {
  // rows
  for (let r=0; r<N; r++) {
    const rowRe = re.slice(r*N, r*N+N);
    const rowIm = im.slice(r*N, r*N+N);
    fft1d(rowRe, rowIm, invert);
    re.set(rowRe, r*N); im.set(rowIm, r*N);
  }
  // cols
  for (let c=0; c<N; c++) {
    const colRe=new Float32Array(N), colIm=new Float32Array(N);
    for(let r=0;r<N;r++){colRe[r]=re[r*N+c];colIm[r]=im[r*N+c];}
    fft1d(colRe,colIm,invert);
    for(let r=0;r<N;r++){re[r*N+c]=colRe[r];im[r*N+c]=colIm[r];}
  }
}

function fftshift(re, im) {
  // shift quadrants
  const h=N/2;
  for(let r=0;r<h;r++){
    for(let c=0;c<h;c++){
      const a=r*N+c, b=(r+h)*N+(c+h);
      [re[a],re[b]]=[re[b],re[a]]; [im[a],im[b]]=[im[b],im[a]];
      const a2=r*N+(c+h), b2=(r+h)*N+c;
      [re[a2],re[b2]]=[re[b2],re[a2]]; [im[a2],im[b2]]=[im[b2],im[a2]];
    }
  }
}

// ─── Scene generators ─────────────────────────────────────────────────────────
function drawScene(scene) {
  const data = new Float32Array(N*N);
  switch(scene) {
    case 'geometric': {
      // rectangle
      for(let r=40;r<130;r++) for(let c=80;c<220;c++) data[r*N+c]=200;
      // small rect top-left overlap
      for(let r=20;r<70;r++) for(let c=30;c<100;c++) data[r*N+c]=160;
      // circle
      const cx=100,cy=175,rad=55;
      for(let r=0;r<N;r++) for(let c=0;c<N;c++)
        if((r-cy)**2+(c-cx)**2<rad*rad) data[r*N+c]=220;
      // diagonal line
      for(let i=0;i<N;i++) { const r=clamp(i,0,N-1),cc=clamp(i,0,N-1); data[r*N+cc]=255; }
      // horizontal stripes
      for(let s=0;s<5;s++){
        const y=170+s*7;
        for(let c=145;c<210;c++) data[y*N+c]=255;
      }
      break;
    }
    case 'circles': {
      for(let r=0;r<N;r++) for(let c=0;c<N;c++){
        const d=Math.sqrt((r-N/2)**2+(c-N/2)**2);
        if(Math.floor(d/20)%2===0) data[r*N+c]=200;
      }
      break;
    }
    case 'lines': {
      for(let r=0;r<N;r++) for(let c=0;c<N;c++){
        if(Math.floor(c/16)%2===0) data[r*N+c]=200;
        if(Math.floor(r/32)%2===0) data[r*N+c]=Math.max(data[r*N+c],140);
      }
      break;
    }
    case 'checkerboard': {
      for(let r=0;r<N;r++) for(let c=0;c<N;c++){
        if((Math.floor(r/24)+Math.floor(c/24))%2===0) data[r*N+c]=200;
      }
      break;
    }
  }
  return data;
}

// ─── Canvas helpers ────────────────────────────────────────────────────────────
function putGray(canvas, data, min, max) {
  const ctx = canvas.getContext('2d');
  const id  = ctx.createImageData(N, N);
  for(let i=0;i<N*N;i++){
    const v = clamp(Math.round((data[i]-min)/(max-min)*255), 0, 255);
    id.data[i*4]=v; id.data[i*4+1]=v; id.data[i*4+2]=v; id.data[i*4+3]=255;
  }
  ctx.putImageData(id,0,0);
}

function putSpectrum(canvas, re, im) {
  const ctx = canvas.getContext('2d');
  const id  = ctx.createImageData(N, N);
  let mx=-Infinity;
  const log = new Float32Array(N*N);
  for(let i=0;i<N*N;i++){
    log[i]=Math.log1p(Math.sqrt(re[i]**2+im[i]**2));
    if(log[i]>mx) mx=log[i];
  }
  for(let i=0;i<N*N;i++){
    const t = log[i]/mx;
    // Map to red-orange-yellow heat
    id.data[i*4]   = clamp(Math.round(t*255+50),0,255);
    id.data[i*4+1] = clamp(Math.round(t*t*160),0,255);
    id.data[i*4+2] = clamp(Math.round(t*40),0,255);
    id.data[i*4+3] = 255;
  }
  ctx.putImageData(id,0,0);
}

function putFilter(canvas, filterData) {
  const ctx = canvas.getContext('2d');
  const id  = ctx.createImageData(N, N);
  for(let i=0;i<N*N;i++){
    const v = clamp(Math.round(filterData[i]*255), 0, 255);
    id.data[i*4]=v; id.data[i*4+1]=v; id.data[i*4+2]=v; id.data[i*4+3]=255;
  }
  ctx.putImageData(id,0,0);
}

// ─── Main pipeline ─────────────────────────────────────────────────────────────
function runPipeline() {
  const cutoff    = parseFloat(document.getElementById('cutoff').value);
  const noiseAmp  = parseFloat(document.getElementById('noise').value);
  const scene     = document.getElementById('scene').value;

  // 1. Original
  const orig = drawScene(scene);
  putGray(document.getElementById('c6'), orig, 0, 255);

  // 2. Add noise
  const noisy = orig.slice();
  for(let i=0;i<N*N;i++) noisy[i] = clamp(noisy[i] + (Math.random()-0.5)*noiseAmp*2, 0, 255);
  putGray(document.getElementById('c1'), noisy, 0, 255);

  // 3. FFT
  const re = new Float32Array(noisy), im = new Float32Array(N*N);
  fft2d(re, im, false);

  // 4. fftshift for visualization
  const reS = re.slice(), imS = im.slice();
  fftshift(reS, imS);
  putSpectrum(document.getElementById('c2'), reS, imS);

  // 5. Build Gaussian filter in shifted domain
  const filterMask = new Float32Array(N*N);
  const sigma2 = 2*cutoff*cutoff;
  for(let r=0;r<N;r++) for(let c=0;c<N;c++){
    const dr=r-N/2, dc=c-N/2;
    filterMask[r*N+c] = Math.exp(-(dr*dr+dc*dc)/sigma2);
  }
  putFilter(document.getElementById('c3'), filterMask);

  // 6. Apply filter in shifted domain, then ifftshift
  const reSF = reS.slice(), imSF = imS.slice();
  for(let i=0;i<N*N;i++){ reSF[i]*=filterMask[i]; imSF[i]*=filterMask[i]; }
  putSpectrum(document.getElementById('c4'), reSF, imSF);

  // 7. Ifftshift then IFFT
  fftshift(reSF, imSF); // ifftshift = fftshift for even N
  fft2d(reSF, imSF, true);

  // 8. Denoised
  putGray(document.getElementById('c5'), reSF, 0, 255);

  // 9. Compute PSNR vs original
  let mse=0;
  for(let i=0;i<N*N;i++){
    const d=clamp(reSF[i],0,255)-orig[i];
    mse+=d*d;
  }
  mse/=N*N;
  const psnr = mse>0 ? 10*Math.log10(255*255/mse) : 99;

  document.getElementById('psnrLabel').textContent = `PSNR: ${psnr.toFixed(1)} dB`;
  document.getElementById('mPSNR').textContent = `${psnr.toFixed(1)} dB`;
  document.getElementById('mMSE').textContent = mse.toFixed(1);
  document.getElementById('mCutoff').textContent = cutoff;
  document.getElementById('mNoise').textContent = noiseAmp;

  // bar: map 10-50dB → 0-100%
  const pct = clamp((psnr-10)/40*100, 0, 100);
  document.getElementById('psnrBar').style.width = pct+'%';
}

// ─── Live controls ─────────────────────────────────────────────────────────────
document.getElementById('cutoff').addEventListener('input', e=>{
  document.getElementById('cutoffVal').textContent = e.target.value;
  runPipeline();
});
document.getElementById('noise').addEventListener('input', e=>{
  document.getElementById('noiseVal').textContent = e.target.value;
  runPipeline();
});
document.getElementById('scene').addEventListener('change', runPipeline);
document.getElementById('runBtn').addEventListener('click', runPipeline);

runPipeline();
</script>
</body>
</html>
