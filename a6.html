<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FFT Low-Pass Filter Visualizer</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Syne:wght@400;700;800&display=swap');

  :root {
    --bg: #080c14;
    --panel: #0e1520;
    --panel2: #131c2b;
    --border: #1e2d45;
    --accent-blue: #3b82f6;
    --accent-red: #ef4444;
    --accent-green: #22c55e;
    --accent-yellow: #f59e0b;
    --text: #e2e8f0;
    --muted: #64748b;
    --glow-blue: rgba(59,130,246,0.35);
    --glow-red: rgba(239,68,68,0.35);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Space Mono', monospace;
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* Noise grain overlay */
  body::before {
    content: '';
    position: fixed; inset: 0;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.04'/%3E%3C/svg%3E");
    pointer-events: none; z-index: 9999; opacity: 0.4;
  }

  header {
    padding: 2rem 2.5rem 1rem;
    border-bottom: 1px solid var(--border);
    display: flex; align-items: flex-end; gap: 1.5rem;
    background: linear-gradient(180deg, #0a1020 0%, transparent 100%);
  }

  header h1 {
    font-family: 'Syne', sans-serif;
    font-weight: 800;
    font-size: clamp(1.4rem, 3vw, 2.2rem);
    letter-spacing: -0.02em;
    line-height: 1;
    background: linear-gradient(135deg, #60a5fa, #a78bfa);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .tag {
    font-size: 0.65rem;
    padding: 3px 8px;
    border: 1px solid var(--accent-blue);
    color: var(--accent-blue);
    border-radius: 2px;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    margin-bottom: 4px;
  }

  .main-layout {
    display: grid;
    grid-template-columns: 280px 1fr;
    gap: 0;
    height: calc(100vh - 90px);
  }

  /* ── LEFT CONTROLS ── */
  .controls {
    background: var(--panel);
    border-right: 1px solid var(--border);
    padding: 1.5rem 1.25rem;
    display: flex;
    flex-direction: column;
    gap: 1.4rem;
    overflow-y: auto;
  }

  .ctrl-section h3 {
    font-family: 'Syne', sans-serif;
    font-size: 0.7rem;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: var(--muted);
    margin-bottom: 0.9rem;
    padding-bottom: 0.4rem;
    border-bottom: 1px solid var(--border);
  }

  label.ctrl-label {
    display: flex; justify-content: space-between; align-items: center;
    font-size: 0.72rem; color: #94a3b8; margin-bottom: 0.4rem;
  }

  label.ctrl-label span {
    font-weight: 700;
    color: var(--accent-yellow);
  }

  input[type=range] {
    width: 100%;
    appearance: none;
    height: 4px;
    border-radius: 2px;
    background: var(--border);
    outline: none;
    margin-bottom: 0.8rem;
    cursor: pointer;
  }

  input[type=range]::-webkit-slider-thumb {
    appearance: none;
    width: 14px; height: 14px;
    border-radius: 50%;
    background: var(--accent-blue);
    box-shadow: 0 0 8px var(--glow-blue);
    cursor: pointer;
  }

  .btn-group {
    display: flex; gap: 0.5rem; flex-wrap: wrap;
  }

  .btn {
    flex: 1;
    padding: 0.5rem 0.6rem;
    font-family: 'Space Mono', monospace;
    font-size: 0.65rem;
    letter-spacing: 0.05em;
    border: 1px solid var(--border);
    background: transparent;
    color: var(--muted);
    cursor: pointer;
    border-radius: 3px;
    transition: all 0.15s;
    text-align: center;
  }

  .btn:hover { border-color: var(--accent-blue); color: var(--accent-blue); }
  .btn.active { background: var(--accent-blue); color: #fff; border-color: var(--accent-blue); box-shadow: 0 0 12px var(--glow-blue); }
  .btn.red.active { background: var(--accent-red); border-color: var(--accent-red); box-shadow: 0 0 12px var(--glow-red); }

  .metric-row {
    display: grid; grid-template-columns: 1fr 1fr; gap: 0.6rem;
  }

  .metric-card {
    background: var(--panel2);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 0.6rem 0.75rem;
  }

  .metric-card .mlabel { font-size: 0.6rem; color: var(--muted); letter-spacing: 0.08em; text-transform: uppercase; }
  .metric-card .mval { font-family: 'Syne', sans-serif; font-size: 1.1rem; font-weight: 800; margin-top: 2px; }
  .metric-card .mval.blue { color: var(--accent-blue); }
  .metric-card .mval.red { color: var(--accent-red); }

  /* frequency response legend */
  .legend-item { display: flex; align-items: center; gap: 0.5rem; font-size: 0.7rem; color: #94a3b8; margin-bottom: 0.3rem; }
  .legend-dot { width: 20px; height: 3px; border-radius: 2px; }

  /* ── RIGHT CANVAS AREA ── */
  .canvas-area {
    display: grid;
    grid-template-rows: 1fr 1fr;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 1px;
    background: var(--border);
    overflow: hidden;
  }

  .canvas-cell {
    background: var(--bg);
    display: flex; flex-direction: column;
    position: relative;
    overflow: hidden;
  }

  .canvas-cell.wide {
    grid-column: span 1;
  }

  .cell-title {
    font-family: 'Syne', sans-serif;
    font-size: 0.65rem;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: var(--muted);
    padding: 0.5rem 0.75rem 0;
    display: flex; justify-content: space-between; align-items: center;
    flex-shrink: 0;
  }

  .cell-badge {
    font-size: 0.55rem;
    padding: 2px 6px;
    border-radius: 2px;
    letter-spacing: 0.08em;
  }

  .cell-badge.ideal { background: rgba(59,130,246,0.15); color: var(--accent-blue); border: 1px solid rgba(59,130,246,0.3); }
  .cell-badge.gauss { background: rgba(239,68,68,0.15); color: var(--accent-red); border: 1px solid rgba(239,68,68,0.3); }
  .cell-badge.input { background: rgba(100,116,139,0.15); color: var(--muted); border: 1px solid rgba(100,116,139,0.3); }
  .cell-badge.spectrum { background: rgba(34,197,94,0.15); color: var(--accent-green); border: 1px solid rgba(34,197,94,0.3); }

  canvas.main-canvas {
    flex: 1;
    width: 100%;
    image-rendering: pixelated;
  }

  /* ── FREQUENCY RESPONSE CHART ── */
  .freq-chart-container {
    background: var(--bg);
    position: relative;
  }

  canvas.freq-canvas {
    width: 100%; height: 100%;
  }

  .psnr-label {
    position: absolute;
    bottom: 6px; right: 8px;
    font-size: 0.6rem;
    font-family: 'Space Mono', monospace;
    color: var(--muted);
  }

  .artifact-note {
    position: absolute;
    bottom: 6px; left: 8px;
    font-size: 0.58rem;
    color: var(--accent-yellow);
    opacity: 0.8;
  }

  /* Scrollbar */
  ::-webkit-scrollbar { width: 4px; }
  ::-webkit-scrollbar-track { background: var(--panel); }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  @keyframes fadeIn { from { opacity: 0; transform: translateY(6px); } to { opacity: 1; transform: none; } }
  .canvas-cell { animation: fadeIn 0.4s ease both; }
  .canvas-cell:nth-child(2) { animation-delay: 0.05s; }
  .canvas-cell:nth-child(3) { animation-delay: 0.10s; }
  .canvas-cell:nth-child(4) { animation-delay: 0.15s; }
  .canvas-cell:nth-child(5) { animation-delay: 0.20s; }
  .canvas-cell:nth-child(6) { animation-delay: 0.25s; }
</style>
</head>
<body>

<header>
  <div>
    <div class="tag">Signal Processing</div>
    <h1>FFT Low-Pass Filter Visualizer</h1>
  </div>
</header>

<div class="main-layout">
  <!-- CONTROLS -->
  <aside class="controls">

    <div class="ctrl-section">
      <h3>Filter Parameters</h3>
      <label class="ctrl-label">Cutoff Frequency <span id="cutoffVal">40</span></label>
      <input type="range" id="cutoff" min="5" max="120" value="40">

      <label class="ctrl-label">Noise Level <span id="noiseVal">0.35</span></label>
      <input type="range" id="noise" min="0" max="100" value="35">

      <label class="ctrl-label">Gaussian σ <span id="sigmaVal">40</span></label>
      <input type="range" id="sigma" min="5" max="120" value="40">
    </div>

    <div class="ctrl-section">
      <h3>Test Image</h3>
      <div class="btn-group">
        <button class="btn active" data-img="geometric">Geometric</button>
        <button class="btn" data-img="lines">Lines</button>
        <button class="btn" data-img="circles">Circles</button>
        <button class="btn" data-img="mixed">Mixed</button>
      </div>
    </div>

    <div class="ctrl-section">
      <h3>Display</h3>
      <div class="btn-group">
        <button class="btn active" data-view="spatial">Spatial</button>
        <button class="btn" data-view="magnitude">|FFT|</button>
      </div>
    </div>

    <div class="ctrl-section">
      <h3>Quality Metrics</h3>
      <div class="metric-row">
        <div class="metric-card">
          <div class="mlabel">Ideal PSNR</div>
          <div class="mval blue" id="psnrIdeal">–</div>
        </div>
        <div class="metric-card">
          <div class="mlabel">Gauss PSNR</div>
          <div class="mval red" id="psnrGauss">–</div>
        </div>
        <div class="metric-card">
          <div class="mlabel">Ringing</div>
          <div class="mval blue" id="ringingScore">–</div>
        </div>
        <div class="metric-card">
          <div class="mlabel">Smoothness</div>
          <div class="mval red" id="smoothScore">–</div>
        </div>
      </div>
    </div>

    <div class="ctrl-section">
      <h3>Frequency Response</h3>
      <div class="legend-item"><div class="legend-dot" style="background:var(--accent-blue)"></div>Ideal (brick-wall)</div>
      <div class="legend-item"><div class="legend-dot" style="background:var(--accent-red)"></div>Gaussian (smooth rolloff)</div>
    </div>

    <div class="ctrl-section">
      <h3>About</h3>
      <p style="font-size:0.65rem;color:var(--muted);line-height:1.6;">
        The <span style="color:var(--accent-blue)">Ideal LPF</span> passes all frequencies below the cutoff and blocks everything above — causing <em>Gibbs ringing</em> at edges.<br><br>
        The <span style="color:var(--accent-red)">Gaussian LPF</span> applies a smooth bell-curve rolloff, producing no ringing but with gentler attenuation.
      </p>
    </div>

  </aside>

  <!-- CANVAS GRID -->
  <div class="canvas-area">

    <div class="canvas-cell">
      <div class="cell-title">Noisy Input <span class="cell-badge input">INPUT</span></div>
      <canvas class="main-canvas" id="cvInput"></canvas>
    </div>

    <div class="canvas-cell">
      <div class="cell-title">Ideal LP Filter <span class="cell-badge ideal">IDEAL</span></div>
      <canvas class="main-canvas" id="cvIdealFilter"></canvas>
    </div>

    <div class="canvas-cell">
      <div class="cell-title">Gaussian LP Filter <span class="cell-badge gauss">GAUSSIAN</span></div>
      <canvas class="main-canvas" id="cvGaussFilter"></canvas>
    </div>

    <div class="canvas-cell freq-chart-container">
      <div class="cell-title">Frequency Cross-Section <span class="cell-badge spectrum">SPECTRUM</span></div>
      <canvas class="freq-canvas" id="cvFreq"></canvas>
    </div>

    <div class="canvas-cell" style="position:relative">
      <div class="cell-title">Ideal Result <span class="cell-badge ideal">IDEAL</span></div>
      <canvas class="main-canvas" id="cvIdealResult"></canvas>
      <div class="artifact-note" id="noteIdeal">⚠ ringing artifacts</div>
      <div class="psnr-label" id="psnrLabelIdeal">PSNR: –</div>
    </div>

    <div class="canvas-cell" style="position:relative">
      <div class="cell-title">Gaussian Result <span class="cell-badge gauss">GAUSSIAN</span></div>
      <canvas class="main-canvas" id="cvGaussResult"></canvas>
      <div class="artifact-note" style="color:var(--accent-green)" id="noteGauss">✓ smooth, no ringing</div>
      <div class="psnr-label" id="psnrLabelGauss">PSNR: –</div>
    </div>

  </div>
</div>

<script>
// ── PARAMETERS ──────────────────────────────────────────────
let N = 256;
let cutoff = 40;
let noiseLevel = 0.35;
let sigma = 40;
let imageType = 'geometric';
let viewMode = 'spatial';

// ── DOM ─────────────────────────────────────────────────────
const cvInput       = document.getElementById('cvInput');
const cvIdealFilter = document.getElementById('cvIdealFilter');
const cvGaussFilter = document.getElementById('cvGaussFilter');
const cvIdealResult = document.getElementById('cvIdealResult');
const cvGaussResult = document.getElementById('cvGaussResult');
const cvFreq        = document.getElementById('cvFreq');

function setCanvasSize(cv) {
  const rect = cv.parentElement.getBoundingClientRect();
  const w = Math.floor(rect.width);
  const h = Math.floor(cv.parentElement.clientHeight - 30);
  if (cv.width !== w || cv.height !== h) {
    cv.width = w; cv.height = h;
  }
}

// ── MATH ────────────────────────────────────────────────────
// Simple DFT on rows, then columns (real-only input, magnitude output)
// Using a fast approach with Float32Arrays

function fft1d(re, im) {
  // Cooley-Tukey in-place, n must be power of 2
  const n = re.length;
  // bit-reverse
  let j = 0;
  for (let i = 1; i < n; i++) {
    let bit = n >> 1;
    for (; j & bit; bit >>= 1) j ^= bit;
    j ^= bit;
    if (i < j) {
      [re[i], re[j]] = [re[j], re[i]];
      [im[i], im[j]] = [im[j], im[i]];
    }
  }
  for (let len = 2; len <= n; len <<= 1) {
    const ang = -2 * Math.PI / len;
    const wRe = Math.cos(ang), wIm = Math.sin(ang);
    for (let i = 0; i < n; i += len) {
      let curRe = 1, curIm = 0;
      for (let k = 0; k < len >> 1; k++) {
        const uRe = re[i+k], uIm = im[i+k];
        const vRe = re[i+k+len/2]*curRe - im[i+k+len/2]*curIm;
        const vIm = re[i+k+len/2]*curIm + im[i+k+len/2]*curRe;
        re[i+k] = uRe+vRe; im[i+k] = uIm+vIm;
        re[i+k+len/2] = uRe-vRe; im[i+k+len/2] = uIm-vIm;
        const newRe = curRe*wRe - curIm*wIm;
        curIm = curRe*wIm + curIm*wRe; curRe = newRe;
      }
    }
  }
}

function ifft1d(re, im) {
  // IFFT = conjugate, FFT, conjugate, divide by n
  for (let i = 0; i < im.length; i++) im[i] = -im[i];
  fft1d(re, im);
  for (let i = 0; i < re.length; i++) { re[i] /= re.length; im[i] = -im[i] / re.length; }
}

function fft2d(re, im, n) {
  // Rows
  for (let r = 0; r < n; r++) {
    const rowRe = re.slice(r*n, r*n+n);
    const rowIm = im.slice(r*n, r*n+n);
    fft1d(rowRe, rowIm);
    re.set(rowRe, r*n); im.set(rowIm, r*n);
  }
  // Cols
  const col = new Float32Array(n), colI = new Float32Array(n);
  for (let c = 0; c < n; c++) {
    for (let r = 0; r < n; r++) { col[r] = re[r*n+c]; colI[r] = im[r*n+c]; }
    fft1d(col, colI);
    for (let r = 0; r < n; r++) { re[r*n+c] = col[r]; im[r*n+c] = colI[r]; }
  }
}

function ifft2d(re, im, n) {
  // Conj
  for (let i = 0; i < im.length; i++) im[i] = -im[i];
  fft2d(re, im, n);
  const nn = n*n;
  for (let i = 0; i < nn; i++) { re[i] /= nn; im[i] = -im[i] / nn; }
}

function fftShift(re, im, n) {
  // Swap quadrants
  const half = n >> 1;
  for (let r = 0; r < half; r++) {
    for (let c = 0; c < half; c++) {
      const a = r*n+c, b = (r+half)*n+(c+half);
      [re[a],re[b]] = [re[b],re[a]]; [im[a],im[b]] = [im[b],im[a]];
    }
    for (let c = half; c < n; c++) {
      const a = r*n+c, b = (r+half)*n+(c-half);
      [re[a],re[b]] = [re[b],re[a]]; [im[a],im[b]] = [im[b],im[a]];
    }
  }
}

// ── IMAGE GENERATORS ────────────────────────────────────────
function genGeometric(n) {
  const img = new Float32Array(n*n);
  // Background
  img.fill(0.05);
  // Big rectangle
  for (let r = 50; r < 160; r++) for (let c = 40; c < 220; c++) img[r*n+c] = 0.7;
  // Small rectangle top-left
  for (let r = 10; r < 60; r++) for (let c = 10; c < 90; c++) img[r*n+c] = 0.5;
  // Big circle
  const cx=110, cy=160, cr=55;
  for (let r = 0; r < n; r++) for (let c = 0; c < n; c++) {
    if ((r-cy)**2+(c-cx)**2 < cr**2) img[r*n+c] = 0.95;
  }
  // Diagonal line
  for (let i = 0; i < n; i++) if (i<n && i<n) {
    const r = i, c = n-1-i;
    if (r>=0&&r<n&&c>=0&&c<n) img[r*n+c] = 1;
  }
  // Horizontal lines
  for (let k=0;k<6;k++) { const r=170+k*6; for (let c=140;c<200;c++) img[r*n+c]=1; }
  return img;
}

function genLines(n) {
  const img = new Float32Array(n*n).fill(0.05);
  for (let c = 20; c < n-20; c+=16) for (let r = 10; r < n-10; r++) img[r*n+c] = 0.9;
  for (let r = 20; r < n-20; r+=24) for (let c = 10; c < n-10; c++) img[r*n+c] = Math.max(img[r*n+c], 0.6);
  return img;
}

function genCircles(n) {
  const img = new Float32Array(n*n).fill(0.05);
  const centers = [[80,80,50],[180,80,40],[80,190,35],[180,190,55],[128,128,25]];
  for (const [cy,cx,cr] of centers)
    for (let r=0;r<n;r++) for (let c=0;c<n;c++)
      if ((r-cy)**2+(c-cx)**2<cr**2) img[r*n+c]=0.85;
  return img;
}

function genMixed(n) {
  const img = genGeometric(n);
  // add checkerboard patch
  for (let r=190;r<230;r++) for (let c=30;c<80;c++)
    img[r*n+c] = ((Math.floor((r-190)/6)+Math.floor((c-30)/6))%2) ? 0.9 : 0.1;
  return img;
}

function genImage(type, n) {
  if (type==='lines') return genLines(n);
  if (type==='circles') return genCircles(n);
  if (type==='mixed') return genMixed(n);
  return genGeometric(n);
}

function addNoise(img, level) {
  const out = new Float32Array(img.length);
  for (let i=0;i<img.length;i++) out[i] = Math.max(0, Math.min(1, img[i] + (Math.random()-0.5)*2*level));
  return out;
}

// ── FILTERS ─────────────────────────────────────────────────
function applyIdealLPF(re, im, n, cut) {
  const half = n>>1;
  for (let r=0;r<n;r++) for (let c=0;c<n;c++) {
    const dr=r-half, dc=c-half;
    const dist=Math.sqrt(dr*dr+dc*dc);
    if (dist>cut) { re[r*n+c]=0; im[r*n+c]=0; }
  }
}

function applyGaussLPF(re, im, n, sig) {
  const half = n>>1;
  const s2 = 2*sig*sig;
  for (let r=0;r<n;r++) for (let c=0;c<n;c++) {
    const dr=r-half, dc=c-half;
    const g = Math.exp(-(dr*dr+dc*dc)/s2);
    re[r*n+c]*=g; im[r*n+c]*=g;
  }
}

// ── PSNR ────────────────────────────────────────────────────
function psnr(ref, out) {
  let mse=0;
  for (let i=0;i<ref.length;i++) mse+=(ref[i]-out[i])**2;
  mse/=ref.length;
  if (mse===0) return 99.9;
  return (10*Math.log10(1/mse)).toFixed(1);
}

// ── DRAW HELPERS ─────────────────────────────────────────────
function drawImageData(cv, pixels, n) {
  const ctx = cv.getContext('2d');
  const W = cv.width, H = cv.height;
  ctx.clearRect(0,0,W,H);
  const tmp = document.createElement('canvas');
  tmp.width = n; tmp.height = n;
  const tctx = tmp.getContext('2d');
  const id = tctx.createImageData(n, n);
  const d = id.data;
  for (let i=0;i<n*n;i++) {
    const v = Math.max(0,Math.min(255, pixels[i]*255));
    d[i*4]=v; d[i*4+1]=v; d[i*4+2]=v; d[i*4+3]=255;
  }
  tctx.putImageData(id, 0, 0);
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(tmp, 0, 0, W, H);
}

function drawFilterMask(cv, mask, n, colorR, colorG, colorB) {
  const ctx = cv.getContext('2d');
  const W = cv.width, H = cv.height;
  ctx.clearRect(0,0,W,H);
  const tmp = document.createElement('canvas');
  tmp.width = n; tmp.height = n;
  const tctx = tmp.getContext('2d');
  const id = tctx.createImageData(n, n);
  const d = id.data;
  for (let i=0;i<n*n;i++) {
    const v = mask[i];
    d[i*4]  = v*colorR;
    d[i*4+1]= v*colorG;
    d[i*4+2]= v*colorB;
    d[i*4+3]=255;
  }
  tctx.putImageData(id, 0, 0);
  ctx.imageSmoothingEnabled = true;
  ctx.drawImage(tmp, 0, 0, W, H);
}

function drawMagnitudeSpectrum(cv, re, im, n) {
  const ctx = cv.getContext('2d');
  const W = cv.width, H = cv.height;
  ctx.clearRect(0,0,W,H);
  const tmp = document.createElement('canvas');
  tmp.width=n; tmp.height=n;
  const tctx=tmp.getContext('2d');
  const id=tctx.createImageData(n,n);
  const d=id.data;
  // find max log magnitude
  let maxM=0;
  const mags=new Float32Array(n*n);
  for (let i=0;i<n*n;i++) {
    mags[i]=Math.log(1+Math.sqrt(re[i]**2+im[i]**2));
    if (mags[i]>maxM) maxM=mags[i];
  }
  for (let i=0;i<n*n;i++) {
    const v=Math.floor(255*mags[i]/maxM);
    d[i*4]=v; d[i*4+1]=Math.floor(v*0.6); d[i*4+2]=0; d[i*4+3]=255;
  }
  tctx.putImageData(id,0,0);
  ctx.imageSmoothingEnabled=false;
  ctx.drawImage(tmp,0,0,W,H);
}

// ── FREQUENCY RESPONSE CHART ─────────────────────────────────
function drawFreqChart(cv, cut, sig, n) {
  const ctx = cv.getContext('2d');
  const W = cv.width, H = cv.height;
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = '#080c14';
  ctx.fillRect(0,0,W,H);

  const padL=42, padR=12, padT=18, padB=28;
  const cW=W-padL-padR, cH=H-padT-padB;

  // Grid
  ctx.strokeStyle='#1e2d45'; ctx.lineWidth=0.5;
  for (let i=0;i<=4;i++) {
    const y=padT+cH*(1-i/4);
    ctx.beginPath(); ctx.moveTo(padL,y); ctx.lineTo(padL+cW,y); ctx.stroke();
    ctx.fillStyle='#475569'; ctx.font='9px Space Mono';
    ctx.textAlign='right';
    ctx.fillText((i/4).toFixed(1), padL-5, y+3);
  }
  for (let i=0;i<=4;i++) {
    const x=padL+cW*i/4;
    ctx.beginPath(); ctx.moveTo(x,padT); ctx.lineTo(x,padT+cH); ctx.stroke();
    ctx.fillStyle='#475569'; ctx.font='9px Space Mono';
    ctx.textAlign='center';
    ctx.fillText(Math.round(n/2*i/4), x, padT+cH+14);
  }

  // Cutoff line
  const cutX = padL + (cut/(n/2))*cW;
  ctx.strokeStyle='rgba(245,158,11,0.4)'; ctx.lineWidth=1; ctx.setLineDash([3,3]);
  ctx.beginPath(); ctx.moveTo(cutX,padT); ctx.lineTo(cutX,padT+cH); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle='rgba(245,158,11,0.7)'; ctx.font='8px Space Mono'; ctx.textAlign='center';
  ctx.fillText('f₀', cutX, padT-3);

  // Ideal
  ctx.strokeStyle='#3b82f6'; ctx.lineWidth=2;
  ctx.beginPath();
  for (let x=0;x<=cW;x++) {
    const f=(x/cW)*(n/2);
    const v = f<=cut ? 1 : 0;
    const px=padL+x, py=padT+cH*(1-v);
    x===0 ? ctx.moveTo(px,py) : ctx.lineTo(px,py);
  }
  ctx.stroke();

  // Gaussian
  const s2=2*sig*sig;
  ctx.strokeStyle='#ef4444'; ctx.lineWidth=2;
  ctx.beginPath();
  for (let x=0;x<=cW;x++) {
    const f=(x/cW)*(n/2);
    const v=Math.exp(-f*f/s2);
    const px=padL+x, py=padT+cH*(1-v);
    x===0 ? ctx.moveTo(px,py) : ctx.lineTo(px,py);
  }
  ctx.stroke();

  // Axes labels
  ctx.fillStyle='#64748b'; ctx.font='9px Space Mono';
  ctx.textAlign='center';
  ctx.fillText('Frequency (cycles)', padL+cW/2, H-4);

  // legend
  ctx.fillStyle='#3b82f6'; ctx.font='8px Space Mono'; ctx.textAlign='left';
  ctx.fillRect(padL+4,padT+4,14,2);
  ctx.fillText('Ideal',padL+22,padT+8);
  ctx.fillStyle='#ef4444';
  ctx.fillRect(padL+4,padT+16,14,2);
  ctx.fillText('Gaussian',padL+22,padT+20);
}

// ── MAIN PIPELINE ────────────────────────────────────────────
let cleanImg=null;
let noisyImg=null;
let idealResult=null, gaussResult=null;

function run() {
  // 1. Generate clean image
  cleanImg = genImage(imageType, N);
  noisyImg = addNoise(cleanImg, noiseLevel);

  // 2. FFT of noisy
  const re = new Float32Array(noisyImg), im = new Float32Array(N*N);
  fft2d(re, im, N);

  // shift for display/filter
  fftShift(re, im, N);

  // 3. Build filter masks
  const half = N>>1;
  const maskIdeal = new Float32Array(N*N);
  const maskGauss = new Float32Array(N*N);
  const s2=2*sigma*sigma;
  for (let r=0;r<N;r++) for (let c=0;c<N;c++) {
    const dr=r-half, dc=c-half;
    const dist=Math.sqrt(dr*dr+dc*dc);
    maskIdeal[r*N+c] = dist<=cutoff ? 1 : 0;
    maskGauss[r*N+c] = Math.exp(-(dr*dr+dc*dc)/s2);
  }

  // 4. Apply filters
  const reI=new Float32Array(re), imI=new Float32Array(im);
  applyIdealLPF(reI, imI, N, cutoff);

  const reG=new Float32Array(re), imG=new Float32Array(im);
  applyGaussLPF(reG, imG, N, sigma);

  // 5. Inverse shift + IFFT
  fftShift(reI, imI, N); fftShift(reG, imG, N);
  const reISave=new Float32Array(re); const imISave=new Float32Array(im);
  ifft2d(reI, imI, N);
  ifft2d(reG, imG, N);

  idealResult = reI;
  gaussResult = reG;

  // 6. Draw
  [cvInput,cvIdealFilter,cvGaussFilter,cvIdealResult,cvGaussResult].forEach(setCanvasSize);
  const fcv=document.getElementById('cvFreq');
  fcv.width=fcv.parentElement.clientWidth;
  fcv.height=fcv.parentElement.clientHeight-30;

  if (viewMode==='magnitude') {
    // Draw shifted magnitudes
    fftShift(re,im,N);
    drawMagnitudeSpectrum(cvInput, re, im, N);
    fftShift(reISave, imISave, N);
    // ideal filtered magnitude
    const reIF=new Float32Array(reISave), imIF=new Float32Array(imISave);
    applyIdealLPF(reIF,imIF,N,cutoff);
    drawMagnitudeSpectrum(cvIdealFilter, reIF, imIF, N);
    const reGF=new Float32Array(reISave), imGF=new Float32Array(imISave);
    applyGaussLPF(reGF,imGF,N,sigma);
    drawMagnitudeSpectrum(cvGaussFilter, reGF, imGF, N);
    // results stay spatial
    drawImageData(cvIdealResult, idealResult, N);
    drawImageData(cvGaussResult, gaussResult, N);
  } else {
    drawImageData(cvInput, noisyImg, N);
    drawFilterMask(cvIdealFilter, maskIdeal, N, 255, 255, 255);
    drawFilterMask(cvGaussFilter, maskGauss, N, 255, 255, 255);
    drawImageData(cvIdealResult, idealResult, N);
    drawImageData(cvGaussResult, gaussResult, N);
  }

  drawFreqChart(fcv, cutoff, sigma, N);

  // 7. Metrics
  const pi = +psnr(cleanImg, idealResult);
  const pg = +psnr(cleanImg, gaussResult);
  document.getElementById('psnrIdeal').textContent = pi + ' dB';
  document.getElementById('psnrGauss').textContent = pg + ' dB';
  document.getElementById('psnrLabelIdeal').textContent = `PSNR: ${pi} dB`;
  document.getElementById('psnrLabelGauss').textContent = `PSNR: ${pg} dB`;

  // Ringing score: variance at edges relative to interior
  function edgeVariance(img) {
    // compare near-edge pixels vs interior
    let edgeSum=0, cnt=0;
    for (let r=0;r<N;r++) for (let c=0;c<N;c++) {
      // check if near a sharp boundary in clean
      if (r>0&&r<N-1&&c>0&&c<N-1) {
        const diff = Math.abs(cleanImg[r*N+c]-cleanImg[(r-1)*N+c])+Math.abs(cleanImg[r*N+c]-cleanImg[r*N+c-1]);
        if (diff>0.3) {
          const localVar = (img[r*N+c]-cleanImg[r*N+c])**2;
          edgeSum+=localVar; cnt++;
        }
      }
    }
    return cnt>0 ? Math.sqrt(edgeSum/cnt) : 0;
  }
  const ri = edgeVariance(idealResult).toFixed(3);
  const rg = edgeVariance(gaussResult).toFixed(3);
  document.getElementById('ringingScore').textContent = ri;
  document.getElementById('smoothScore').textContent = rg;
}

// ── CONTROLS ────────────────────────────────────────────────
const cutoffEl=document.getElementById('cutoff');
const noiseEl=document.getElementById('noise');
const sigmaEl=document.getElementById('sigma');

cutoffEl.addEventListener('input', ()=>{
  cutoff=+cutoffEl.value;
  document.getElementById('cutoffVal').textContent=cutoff;
  scheduleRun();
});
noiseEl.addEventListener('input', ()=>{
  noiseLevel=noiseEl.value/100;
  document.getElementById('noiseVal').textContent=noiseLevel.toFixed(2);
  scheduleRun();
});
sigmaEl.addEventListener('input', ()=>{
  sigma=+sigmaEl.value;
  document.getElementById('sigmaVal').textContent=sigma;
  scheduleRun();
});

document.querySelectorAll('[data-img]').forEach(b=>{
  b.addEventListener('click', ()=>{
    document.querySelectorAll('[data-img]').forEach(x=>x.classList.remove('active'));
    b.classList.add('active');
    imageType=b.dataset.img;
    scheduleRun();
  });
});

document.querySelectorAll('[data-view]').forEach(b=>{
  b.addEventListener('click', ()=>{
    document.querySelectorAll('[data-view]').forEach(x=>x.classList.remove('active'));
    b.classList.add('active');
    viewMode=b.dataset.view;
    scheduleRun();
  });
});

let timer=null;
function scheduleRun() {
  if (timer) clearTimeout(timer);
  timer = setTimeout(run, 60);
}

window.addEventListener('resize', ()=>scheduleRun());

// Initial run
run();
</script>
</body>
</html>
