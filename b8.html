<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FFT ¬∑ np.real() Explained</title>
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Syne:wght@400;700;800&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #050a0f;
    --panel: #0a1420;
    --border: #1a3048;
    --accent: #00e5ff;
    --accent2: #ff4757;
    --accent3: #2ed573;
    --muted: #4a6a80;
    --text: #c8dde8;
    --bright: #eaf6ff;
    --imaginary: rgba(255, 71, 87, 0.6);
    --real-color: #00e5ff;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Space Mono', monospace;
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* Grid noise background */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background-image:
      linear-gradient(rgba(0,229,255,0.03) 1px, transparent 1px),
      linear-gradient(90deg, rgba(0,229,255,0.03) 1px, transparent 1px);
    background-size: 40px 40px;
    pointer-events: none;
    z-index: 0;
  }

  .container {
    position: relative;
    z-index: 1;
    max-width: 1100px;
    margin: 0 auto;
    padding: 40px 24px 80px;
  }

  /* ‚îÄ‚îÄ Header ‚îÄ‚îÄ */
  header {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-bottom: 48px;
    border-left: 3px solid var(--accent);
    padding-left: 20px;
  }
  .tag {
    font-size: 10px;
    letter-spacing: 4px;
    text-transform: uppercase;
    color: var(--accent);
    opacity: 0.8;
  }
  h1 {
    font-family: 'Syne', sans-serif;
    font-size: clamp(28px, 5vw, 52px);
    font-weight: 800;
    color: var(--bright);
    line-height: 1.1;
  }
  h1 span { color: var(--accent); }
  .subtitle {
    font-size: 13px;
    color: var(--muted);
    max-width: 520px;
    line-height: 1.8;
    margin-top: 4px;
  }

  /* ‚îÄ‚îÄ Pipeline ‚îÄ‚îÄ */
  .pipeline {
    display: grid;
    grid-template-columns: 1fr auto 1fr auto 1fr auto 1fr;
    align-items: center;
    gap: 0;
    margin-bottom: 48px;
    overflow-x: auto;
  }
  .pipe-step {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 16px 14px;
    text-align: center;
    transition: border-color 0.3s, box-shadow 0.3s;
  }
  .pipe-step.active {
    border-color: var(--accent);
    box-shadow: 0 0 20px rgba(0,229,255,0.15);
  }
  .pipe-step.highlight {
    border-color: var(--accent3);
    box-shadow: 0 0 20px rgba(46,213,115,0.2);
  }
  .pipe-step .step-num {
    font-size: 10px;
    letter-spacing: 2px;
    color: var(--muted);
    margin-bottom: 6px;
  }
  .pipe-step .step-name {
    font-family: 'Syne', sans-serif;
    font-size: 13px;
    font-weight: 700;
    color: var(--bright);
  }
  .pipe-step .step-code {
    font-size: 10px;
    color: var(--accent);
    margin-top: 4px;
  }
  .pipe-arrow {
    color: var(--muted);
    font-size: 18px;
    padding: 0 8px;
    flex-shrink: 0;
  }

  /* ‚îÄ‚îÄ Main grid ‚îÄ‚îÄ */
  .viz-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin-bottom: 20px;
  }
  @media (max-width: 700px) { .viz-grid { grid-template-columns: 1fr; } }

  .card {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 24px;
    transition: border-color 0.3s;
  }
  .card:hover { border-color: var(--muted); }
  .card-label {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 16px;
  }
  .dot {
    width: 8px; height: 8px; border-radius: 50%;
    background: var(--accent);
    box-shadow: 0 0 8px var(--accent);
  }
  .dot.red { background: var(--accent2); box-shadow: 0 0 8px var(--accent2); }
  .dot.green { background: var(--accent3); box-shadow: 0 0 8px var(--accent3); }
  .card-title {
    font-family: 'Syne', sans-serif;
    font-size: 14px;
    font-weight: 700;
    color: var(--bright);
  }
  canvas {
    width: 100%;
    height: 160px;
    display: block;
    border-radius: 6px;
    background: #030810;
  }

  /* ‚îÄ‚îÄ Complex plane widget ‚îÄ‚îÄ */
  .complex-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin-bottom: 20px;
  }
  @media (max-width: 700px) { .complex-row { grid-template-columns: 1fr; } }

  .complex-plane-wrap {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  .plane-canvas {
    width: 100%;
    aspect-ratio: 1;
    max-height: 220px;
    border-radius: 6px;
    background: #030810;
    display: block;
  }

  /* ‚îÄ‚îÄ Slider ‚îÄ‚îÄ */
  .controls {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 24px;
    margin-bottom: 20px;
  }
  .ctrl-title {
    font-family: 'Syne', sans-serif;
    font-size: 13px;
    font-weight: 700;
    color: var(--accent);
    letter-spacing: 2px;
    text-transform: uppercase;
    margin-bottom: 20px;
  }
  .ctrl-row {
    display: flex;
    align-items: center;
    gap: 16px;
    margin-bottom: 14px;
    flex-wrap: wrap;
  }
  label { font-size: 11px; color: var(--muted); min-width: 140px; }
  input[type=range] {
    -webkit-appearance: none;
    flex: 1; min-width: 120px;
    height: 3px;
    background: var(--border);
    border-radius: 2px;
    outline: none;
  }
  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 14px; height: 14px;
    border-radius: 50%;
    background: var(--accent);
    box-shadow: 0 0 8px var(--accent);
    cursor: pointer;
  }
  .val {
    font-size: 12px;
    color: var(--accent);
    min-width: 50px;
    text-align: right;
  }

  /* ‚îÄ‚îÄ Number display ‚îÄ‚îÄ */
  .number-table {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 24px;
    margin-bottom: 20px;
  }
  .nt-title {
    font-family: 'Syne', sans-serif;
    font-size: 13px;
    font-weight: 700;
    color: var(--bright);
    margin-bottom: 16px;
  }
  .num-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 10px;
  }
  .num-cell {
    background: #030810;
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 10px 12px;
    font-size: 11px;
  }
  .num-cell .idx { color: var(--muted); margin-bottom: 4px; }
  .num-cell .complex-val { color: var(--accent2); margin-bottom: 2px; }
  .num-cell .real-val { color: var(--accent3); }
  .num-cell .imag-noise { color: rgba(255,71,87,0.5); font-size: 10px; }

  /* ‚îÄ‚îÄ Code box ‚îÄ‚îÄ */
  .code-section {
    background: #020609;
    border: 1px solid var(--border);
    border-left: 3px solid var(--accent3);
    border-radius: 12px;
    padding: 24px;
    margin-bottom: 20px;
    overflow-x: auto;
  }
  pre {
    font-family: 'Space Mono', monospace;
    font-size: 12.5px;
    line-height: 2;
    color: var(--text);
  }
  .c-kw { color: #ff79c6; }
  .c-fn { color: var(--accent); }
  .c-str { color: #f1fa8c; }
  .c-cm { color: var(--muted); font-style: italic; }
  .c-num { color: var(--accent3); }
  .c-hi { background: rgba(46,213,115,0.12); border-radius: 3px; padding: 0 2px; }

  /* ‚îÄ‚îÄ Explanation callout ‚îÄ‚îÄ */
  .callout {
    border: 1px solid var(--accent3);
    border-radius: 12px;
    padding: 20px 24px;
    background: rgba(46,213,115,0.04);
    margin-bottom: 20px;
    display: flex;
    gap: 16px;
    align-items: flex-start;
  }
  .callout-icon { font-size: 22px; flex-shrink: 0; margin-top: 2px; }
  .callout-text { font-size: 12.5px; line-height: 1.9; color: var(--text); }
  .callout-text strong { color: var(--accent3); }

  /* Animations */
  @keyframes fadeUp {
    from { opacity:0; transform: translateY(20px); }
    to   { opacity:1; transform: translateY(0); }
  }
  .card, .controls, .number-table, .code-section, .callout, .pipeline {
    animation: fadeUp 0.5s ease both;
  }

  /* scan line effect on canvases */
  canvas { image-rendering: pixelated; }

  .btn {
    background: transparent;
    border: 1px solid var(--accent);
    color: var(--accent);
    font-family: 'Space Mono', monospace;
    font-size: 11px;
    padding: 8px 18px;
    border-radius: 6px;
    cursor: pointer;
    letter-spacing: 1px;
    transition: background 0.2s, color 0.2s;
  }
  .btn:hover { background: var(--accent); color: var(--bg); }
  .btn-row { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 16px; }
</style>
</head>
<body>
<div class="container">

  <header>
    <div class="tag">Signal Processing ¬∑ Image Reconstruction</div>
    <h1>FFT &amp; <span>np.real()</span></h1>
    <p class="subtitle">When you apply an inverse FFT on real-valued image data, floating-point arithmetic leaves behind tiny imaginary residuals. <code>np.real()</code> discards them ‚Äî keeping only the true pixel intensities.</p>
  </header>

  <!-- Pipeline -->
  <div class="pipeline">
    <div class="pipe-step active">
      <div class="step-num">01</div>
      <div class="step-name">Pixel Array</div>
      <div class="step-code">img[y, x]</div>
    </div>
    <div class="pipe-arrow">‚Üí</div>
    <div class="pipe-step active">
      <div class="step-num">02</div>
      <div class="step-name">FFT</div>
      <div class="step-code">np.fft.fft2()</div>
    </div>
    <div class="pipe-arrow">‚Üí</div>
    <div class="pipe-step active">
      <div class="step-num">03</div>
      <div class="step-name">Process</div>
      <div class="step-code">filter / edit</div>
    </div>
    <div class="pipe-arrow">‚Üí</div>
    <div class="pipe-step active">
      <div class="step-num">04</div>
      <div class="step-name">IFFT</div>
      <div class="step-code">np.fft.ifft2()</div>
    </div>
    <div class="pipe-arrow">‚Üí</div>
    <div class="pipe-step highlight">
      <div class="step-num">05</div>
      <div class="step-name">np.real()</div>
      <div class="step-code">drop Œµ¬∑j noise</div>
    </div>
    <div class="pipe-arrow">‚Üí</div>
    <div class="pipe-step active">
      <div class="step-num">06</div>
      <div class="step-name">Pixels ‚úì</div>
      <div class="step-code">uint8 / float</div>
    </div>
  </div>

  <!-- Controls -->
  <div class="controls">
    <div class="ctrl-title">‚öô Signal Parameters</div>
    <div class="ctrl-row">
      <label>Signal Frequency</label>
      <input type="range" id="freq" min="1" max="8" value="3" step="0.5">
      <div class="val" id="freq-val">3</div>
    </div>
    <div class="ctrl-row">
      <label>Noise Amplitude (√ó10‚Åª¬π‚Å¥)</label>
      <input type="range" id="noise" min="1" max="20" value="5" step="1">
      <div class="val" id="noise-val">5</div>
    </div>
    <div class="ctrl-row">
      <label>Signal Complexity</label>
      <input type="range" id="harmonics" min="1" max="4" value="2" step="1">
      <div class="val" id="harmonics-val">2</div>
    </div>
    <div class="btn-row">
      <button class="btn" id="animate-btn">‚ñ∂ ANIMATE</button>
      <button class="btn" id="random-btn">‚Ü∫ RANDOMIZE</button>
    </div>
  </div>

  <!-- Charts -->
  <div class="viz-grid">
    <div class="card">
      <div class="card-label"><div class="dot"></div><div class="card-title">Original Signal (Real Pixels)</div></div>
      <canvas id="c-original"></canvas>
    </div>
    <div class="card">
      <div class="card-label"><div class="dot"></div><div class="card-title">FFT Magnitude Spectrum</div></div>
      <canvas id="c-fft"></canvas>
    </div>
    <div class="card">
      <div class="card-label"><div class="dot red"></div><div class="card-title">IFFT Output (with Œµ¬∑j residuals)</div></div>
      <canvas id="c-ifft-complex"></canvas>
    </div>
    <div class="card">
      <div class="card-label"><div class="dot green"></div><div class="card-title">np.real() ‚Üí Clean Pixels ‚úì</div></div>
      <canvas id="c-real"></canvas>
    </div>
  </div>

  <!-- Complex plane -->
  <div class="complex-row">
    <div class="card">
      <div class="card-label"><div class="dot red"></div><div class="card-title">Complex Plane ‚Äî Residuals</div></div>
      <canvas class="plane-canvas" id="c-plane" width="260" height="220"></canvas>
      <div style="font-size:10px; color:var(--muted); margin-top:8px;">Each dot = one IFFT output sample. Real axis (x) holds true value. Imaginary axis (y) should be zero ‚Äî floating-point leaves tiny Œµ¬∑j offsets. np.real() projects all points onto the x-axis.</div>
    </div>
    <div class="card">
      <div class="card-label"><div class="dot green"></div><div class="card-title">Imaginary Residual Distribution</div></div>
      <canvas id="c-residual" height="220"></canvas>
      <div style="font-size:10px; color:var(--muted); margin-top:8px;">Distribution of imaginary parts. Centered near zero (~1e-14). These are pure floating-point artifacts ‚Äî not real signal content.</div>
    </div>
  </div>

  <!-- Number table -->
  <div class="number-table">
    <div class="nt-title">Sample IFFT Values ‚Äî Before &amp; After np.real()</div>
    <div class="num-grid" id="num-grid"></div>
  </div>

  <!-- Code -->
  <div class="code-section">
<pre><span class="c-kw">import</span> numpy <span class="c-kw">as</span> np

<span class="c-cm"># Your image pixel intensities (purely real)</span>
image = np.array(pixels, dtype=np.float64)

<span class="c-cm"># Step 1: Forward FFT ‚Üí complex frequency domain</span>
F = <span class="c-fn">np.fft.fft2</span>(image)

<span class="c-cm"># Step 2: Process (e.g., low-pass filter, denoise)</span>
F_filtered = apply_filter(F)

<span class="c-cm"># Step 3: Inverse FFT ‚Üí should be real, but floating-point</span>
<span class="c-cm">#         arithmetic leaves residuals like 2.13e-14j</span>
result_complex = <span class="c-fn">np.fft.ifft2</span>(F_filtered)

<span class="c-cm"># Without np.real():</span>
<span class="c-cm"># result_complex[0,0] ‚Üí 142.000000 + 2.13e-14j  ‚Üê tiny Œµ¬∑j</span>
<span class="c-cm"># result_complex[1,0] ‚Üí 89.000000  - 1.07e-14j  ‚Üê pure noise</span>

<span class="c-cm"># Step 4: ‚úÖ  Discard imaginary residuals</span>
pixels_clean = <span class="c-hi"><span class="c-fn">np.real</span>(result_complex)</span>

<span class="c-cm"># pixels_clean[0,0] ‚Üí 142.000000  ‚úì real pixel intensity</span>
<span class="c-cm"># pixels_clean[1,0] ‚Üí  89.000000  ‚úì real pixel intensity</span>

<span class="c-cm"># Clip &amp; convert to uint8 for display</span>
output = <span class="c-fn">np.clip</span>(pixels_clean, <span class="c-num">0</span>, <span class="c-num">255</span>).<span class="c-fn">astype</span>(np.uint8)
</pre>
  </div>

  <!-- Callout -->
  <div class="callout">
    <div class="callout-icon">üí°</div>
    <div class="callout-text">
      <strong>Why does this happen?</strong> The FFT and IFFT are theoretically inverse operations ‚Äî applying both to a real signal should return exactly the same real values. In practice, computers use <strong>IEEE 754 floating-point arithmetic</strong>, which cannot represent most numbers exactly. Each multiply/add accumulates a rounding error on the order of <strong>machine epsilon (~2.22√ó10‚Åª¬π‚Å∂)</strong>. After thousands of operations, these stack up to residuals like <code>1.5e-14j</code>. They carry <strong>zero real information</strong> ‚Äî only floating-point noise. <strong>np.real()</strong> simply takes the real component and throws away the imaginary axis entirely, giving you clean pixel intensities ready for display or further processing.
    </div>
  </div>

</div>

<script>
// ‚îÄ‚îÄ Utilities ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function lerp(a, b, t) { return a + (b - a) * t; }

function makeSignal(N, freq, harmonics, phase = 0) {
  const arr = new Float64Array(N);
  // Each harmonic gets a fixed static offset + the animated phase
  const staticOffsets = [0.0, 0.4, 1.1, 2.3];
  for (let i = 0; i < N; i++) {
    let v = 0;
    for (let h = 1; h <= harmonics; h++) {
      v += Math.sin(2 * Math.PI * freq * h * i / N + staticOffsets[(h - 1) % 4] + phase * h) / h;
    }
    arr[i] = (v + 1.5) / 3 * 180 + 30;
  }
  return arr;
}

// Minimal DFT (N=64 is fine for display)
function fft(re, im) {
  const N = re.length;
  const mag = new Float64Array(N);
  for (let k = 0; k < N; k++) {
    let sumRe = 0, sumIm = 0;
    for (let n = 0; n < N; n++) {
      const angle = -2 * Math.PI * k * n / N;
      sumRe += re[n] * Math.cos(angle) - im[n] * Math.sin(angle);
      sumIm += re[n] * Math.sin(angle) + im[n] * Math.cos(angle);
    }
    mag[k] = Math.sqrt(sumRe * sumRe + sumIm * sumIm);
  }
  return mag;
}

function simulateIFFT(signal, noiseScale) {
  // Simulate IFFT output: real part = signal, imaginary = tiny Œµ¬∑j
  const N = signal.length;
  const realPart = new Float64Array(N);
  const imagPart = new Float64Array(N);
  for (let i = 0; i < N; i++) {
    realPart[i] = signal[i];
    // Simulate floating-point residuals: ~1e-14 range
    imagPart[i] = (Math.random() - 0.5) * 2 * noiseScale * 1e-14;
  }
  return { realPart, imagPart };
}

// ‚îÄ‚îÄ Canvas drawing ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawWave(canvas, data, color, fillColor, label) {
  const ctx = canvas.getContext('2d');
  const W = canvas.offsetWidth, H = canvas.offsetHeight;
  canvas.width = W; canvas.height = H;

  ctx.clearRect(0, 0, W, H);

  // subtle scan lines
  for (let y = 0; y < H; y += 4) {
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.fillRect(0, y, W, 1);
  }

  const min = Math.min(...data), max = Math.max(...data);
  const range = max - min || 1;
  const N = data.length;
  const pad = 20;

  const x = i => pad + (i / (N - 1)) * (W - pad * 2);
  const y = v => H - pad - ((v - min) / range) * (H - pad * 2);

  // Fill
  if (fillColor) {
    ctx.beginPath();
    ctx.moveTo(x(0), H - pad);
    for (let i = 0; i < N; i++) ctx.lineTo(x(i), y(data[i]));
    ctx.lineTo(x(N - 1), H - pad);
    ctx.closePath();
    ctx.fillStyle = fillColor;
    ctx.fill();
  }

  // Line
  ctx.beginPath();
  ctx.moveTo(x(0), y(data[0]));
  for (let i = 1; i < N; i++) ctx.lineTo(x(i), y(data[i]));
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.shadowColor = color;
  ctx.shadowBlur = 8;
  ctx.stroke();
  ctx.shadowBlur = 0;

  // Dots at extremes
  [0, Math.floor(N / 3), Math.floor(2 * N / 3), N - 1].forEach(i => {
    ctx.beginPath();
    ctx.arc(x(i), y(data[i]), 3, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
  });

  if (label) {
    ctx.font = '10px Space Mono';
    ctx.fillStyle = 'rgba(200,221,232,0.4)';
    ctx.fillText(label, pad + 4, pad + 14);
  }
}

function drawBarSpectrum(canvas, data, color) {
  const ctx = canvas.getContext('2d');
  const W = canvas.offsetWidth, H = canvas.offsetHeight;
  canvas.width = W; canvas.height = H;

  const half = Math.floor(data.length / 2);
  const slice = data.slice(0, half);
  const max = Math.max(...slice) || 1;
  const pad = 20;
  const bw = (W - pad * 2) / half;

  for (let k = 0; k < half; k++) {
    const bh = (slice[k] / max) * (H - pad * 2);
    const xp = pad + k * bw;
    const grad = ctx.createLinearGradient(0, H - pad - bh, 0, H - pad);
    grad.addColorStop(0, color);
    grad.addColorStop(1, 'rgba(0,229,255,0.05)');
    ctx.fillStyle = grad;
    ctx.fillRect(xp + 1, H - pad - bh, bw - 2, bh);
  }

  // Frequency labels
  ctx.font = '9px Space Mono';
  ctx.fillStyle = 'rgba(74,106,128,0.8)';
  for (let k = 0; k <= 4; k++) {
    ctx.fillText(k * Math.floor(half / 4), pad + k * (W - pad * 2) / 4, H - 4);
  }
}

function drawComplexWithImag(canvas, realPart, imagPart) {
  const ctx = canvas.getContext('2d');
  const W = canvas.offsetWidth, H = canvas.offsetHeight;
  canvas.width = W; canvas.height = H;

  const min = Math.min(...realPart), max = Math.max(...realPart);
  const range = max - min || 1;
  const N = realPart.length;
  const pad = 20;

  const x = i => pad + (i / (N - 1)) * (W - pad * 2);

  // Draw imaginary "shimmer"
  for (let i = 0; i < N - 1; i++) {
    const r1 = realPart[i], r2 = realPart[i + 1];
    const im1 = imagPart[i], im2 = imagPart[i + 1];
    const scale = 5e12; // scale up so visible
    const yr1 = H - pad - ((r1 - min) / range) * (H - pad * 2);
    const yr2 = H - pad - ((r2 - min) / range) * (H - pad * 2);

    ctx.beginPath();
    ctx.moveTo(x(i), yr1 + im1 * scale);
    ctx.lineTo(x(i + 1), yr2 + im2 * scale);
    ctx.strokeStyle = 'rgba(255,71,87,0.6)';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // vertical residual lines
    ctx.beginPath();
    ctx.moveTo(x(i), yr1);
    ctx.lineTo(x(i), yr1 + im1 * scale);
    ctx.strokeStyle = 'rgba(255,71,87,0.2)';
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  // Real line on top
  ctx.beginPath();
  const yy = v => H - pad - ((v - min) / range) * (H - pad * 2);
  ctx.moveTo(x(0), yy(realPart[0]));
  for (let i = 1; i < N; i++) ctx.lineTo(x(i), yy(realPart[i]));
  ctx.strokeStyle = 'rgba(255,71,87,0.9)';
  ctx.lineWidth = 2;
  ctx.shadowColor = '#ff4757';
  ctx.shadowBlur = 8;
  ctx.stroke();
  ctx.shadowBlur = 0;

  ctx.font = '9px Space Mono';
  ctx.fillStyle = 'rgba(255,71,87,0.6)';
  ctx.fillText('red = Œµ¬∑j residuals (scaled √ó5e12)', pad + 4, pad + 14);
}

function drawPlane(canvas, realPart, imagPart) {
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0, 0, W, H);

  const cx = W / 2, cy = H / 2;
  const scale = 2.5;
  const noiseScale = 1e14;

  // Grid
  ctx.strokeStyle = 'rgba(26,48,72,0.8)';
  ctx.lineWidth = 1;
  for (let x = 0; x <= W; x += 30) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke(); }
  for (let y = 0; y <= H; y += 30) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke(); }

  // Axes
  ctx.strokeStyle = 'rgba(0,229,255,0.3)';
  ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(W, cy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, H); ctx.stroke();

  // Labels
  ctx.font = '9px Space Mono';
  ctx.fillStyle = 'rgba(0,229,255,0.5)';
  ctx.fillText('Real ‚Üí', W - 46, cy - 6);
  ctx.fillText('Imag', cx + 4, 14);
  ctx.fillText('(√ó1e-14)', cx + 4, 26);

  // Target line (real axis)
  ctx.strokeStyle = 'rgba(46,213,115,0.25)';
  ctx.setLineDash([4, 4]);
  ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(W, cy); ctx.stroke();
  ctx.setLineDash([]);

  // Points
  const min = Math.min(...realPart), max = Math.max(...realPart);
  const range = max - min || 1;
  const halfW = W / 2 - 20;

  for (let i = 0; i < realPart.length; i++) {
    const px = 20 + ((realPart[i] - min) / range) * (W - 40);
    const py = cy - imagPart[i] * noiseScale * scale;

    // Line to real axis
    ctx.beginPath();
    ctx.moveTo(px, py);
    ctx.lineTo(px, cy);
    ctx.strokeStyle = 'rgba(255,71,87,0.2)';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Point
    ctx.beginPath();
    ctx.arc(px, py, 3, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,71,87,0.75)';
    ctx.shadowColor = '#ff4757';
    ctx.shadowBlur = 4;
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // np.real() projection dots
  for (let i = 0; i < realPart.length; i++) {
    const px = 20 + ((realPart[i] - min) / range) * (W - 40);
    ctx.beginPath();
    ctx.arc(px, cy, 2.5, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(46,213,115,0.9)';
    ctx.fill();
  }

  ctx.font = '9px Space Mono';
  ctx.fillStyle = 'rgba(255,71,87,0.6)';
  ctx.fillText('‚óè IFFT output', 8, H - 20);
  ctx.fillStyle = 'rgba(46,213,115,0.8)';
  ctx.fillText('‚óè np.real() result', 8, H - 8);
}

function drawResiduals(canvas, imagPart) {
  const ctx = canvas.getContext('2d');
  const W = canvas.offsetWidth, H = canvas.offsetHeight;
  canvas.width = W; canvas.height = H;

  const bins = 20;
  const hist = new Int32Array(bins);
  const scale = 1e14;
  const min = Math.min(...imagPart) * scale;
  const max = Math.max(...imagPart) * scale;
  const range = max - min || 1;

  for (let v of imagPart) {
    const b = Math.floor(((v * scale - min) / range) * (bins - 1));
    hist[Math.max(0, Math.min(bins - 1, b))]++;
  }

  const maxH = Math.max(...hist);
  const pad = { t: 16, b: 24, l: 24, r: 16 };
  const bw = (W - pad.l - pad.r) / bins;

  for (let b = 0; b < bins; b++) {
    const bh = (hist[b] / maxH) * (H - pad.t - pad.b);
    const xp = pad.l + b * bw;
    const yp = H - pad.b - bh;

    const grad = ctx.createLinearGradient(0, yp, 0, H - pad.b);
    grad.addColorStop(0, 'rgba(255,71,87,0.9)');
    grad.addColorStop(1, 'rgba(255,71,87,0.1)');
    ctx.fillStyle = grad;
    ctx.fillRect(xp + 1, yp, bw - 2, bh);
  }

  // Axis
  ctx.strokeStyle = 'rgba(74,106,128,0.5)';
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(pad.l, H - pad.b); ctx.lineTo(W - pad.r, H - pad.b); ctx.stroke();

  // Labels
  ctx.font = '9px Space Mono';
  ctx.fillStyle = 'rgba(74,106,128,0.8)';
  ctx.fillText(min.toFixed(1) + 'e-14', pad.l, H - 4);
  ctx.fillText(max.toFixed(1) + 'e-14', W - pad.r - 50, H - 4);
  ctx.fillText('0', pad.l + (W - pad.l - pad.r) / 2 - 4, H - 4);

  ctx.fillStyle = 'rgba(255,71,87,0.6)';
  ctx.fillText('imaginary residuals (√ó1e-14)', pad.l, 12);
}

function buildTable(realPart, imagPart) {
  const grid = document.getElementById('num-grid');
  grid.innerHTML = '';
  for (let i = 0; i < Math.min(8, realPart.length); i++) {
    const cell = document.createElement('div');
    cell.className = 'num-cell';
    const sign = imagPart[i] >= 0 ? '+' : '-';
    cell.innerHTML = `
      <div class="idx">index [${i}]</div>
      <div class="complex-val">IFFT: ${realPart[i].toFixed(4)}<span class="imag-noise"> ${sign} ${Math.abs(imagPart[i]).toExponential(2)}j</span></div>
      <div class="real-val">np.real(): ${realPart[i].toFixed(4)}</div>
    `;
    grid.appendChild(cell);
  }
}

// ‚îÄ‚îÄ State ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let animating = false;
let animT = 0;
let animFrame;
let seed = 0;

function getParams() {
  return {
    freq: parseFloat(document.getElementById('freq').value),
    noise: parseFloat(document.getElementById('noise').value),
    harmonics: parseInt(document.getElementById('harmonics').value),
  };
}

function render(phase = 0) {
  const { freq, noise, harmonics } = getParams();
  const N = 64;
  const signal = makeSignal(N, freq, harmonics, phase);

  const im = new Float64Array(N);
  const mag = fft(signal, im);

  const { realPart, imagPart } = simulateIFFT(signal, noise);

  // Draw
  drawWave(
    document.getElementById('c-original'), signal,
    '#00e5ff', 'rgba(0,229,255,0.06)', 'pixel intensities'
  );
  drawBarSpectrum(document.getElementById('c-fft'), mag, '#00e5ff');
  drawComplexWithImag(document.getElementById('c-ifft-complex'), realPart, imagPart);
  drawWave(
    document.getElementById('c-real'), realPart,
    '#2ed573', 'rgba(46,213,115,0.06)', 'np.real() output'
  );
  drawPlane(document.getElementById('c-plane'), realPart, imagPart);
  drawResiduals(document.getElementById('c-residual'), imagPart);
  buildTable(realPart, imagPart);
}

// ‚îÄ‚îÄ Controls ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
['freq', 'noise', 'harmonics'].forEach(id => {
  const el = document.getElementById(id);
  el.addEventListener('input', () => {
    document.getElementById(id + '-val').textContent = el.value;
    render();
  });
});

document.getElementById('animate-btn').addEventListener('click', function () {
  animating = !animating;
  this.textContent = animating ? '‚èπ STOP' : '‚ñ∂ ANIMATE';
  if (animating) tick();
  else cancelAnimationFrame(animFrame);
});

document.getElementById('random-btn').addEventListener('click', () => {
  seed = Math.floor(Math.random() * 100);
  document.getElementById('freq').value = (Math.random() * 6 + 1).toFixed(1);
  document.getElementById('harmonics').value = Math.floor(Math.random() * 4) + 1;
  document.getElementById('noise').value = Math.floor(Math.random() * 18) + 2;
  ['freq', 'harmonics', 'noise'].forEach(id => {
    document.getElementById(id + '-val').textContent = document.getElementById(id).value;
  });
  render();
});

function tick() {
  if (!animating) return;
  animT += 0.04;
  render(animT);
  animFrame = requestAnimationFrame(tick);
}

// Initial render
render();
</script>
</body>
</html>
