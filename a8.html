<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FFT PSNR Analyzer</title>
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=DM+Sans:wght@300;400;500;600&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0a0e1a;
    --panel: #0f1525;
    --border: #1e2d4a;
    --accent: #00d4ff;
    --accent2: #ff4757;
    --accent3: #2ed573;
    --text: #e8f0ff;
    --muted: #5a7090;
    --grid: #141e30;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'DM Sans', sans-serif;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 40px 20px;
    background-image: 
      radial-gradient(ellipse at 20% 0%, rgba(0,212,255,0.05) 0%, transparent 50%),
      radial-gradient(ellipse at 80% 100%, rgba(46,213,115,0.04) 0%, transparent 50%);
  }

  header {
    text-align: center;
    margin-bottom: 36px;
  }

  .badge {
    display: inline-block;
    background: rgba(0,212,255,0.1);
    border: 1px solid rgba(0,212,255,0.3);
    color: var(--accent);
    font-family: 'Space Mono', monospace;
    font-size: 10px;
    letter-spacing: 3px;
    text-transform: uppercase;
    padding: 4px 14px;
    border-radius: 2px;
    margin-bottom: 14px;
  }

  h1 {
    font-family: 'Space Mono', monospace;
    font-size: clamp(20px, 4vw, 32px);
    font-weight: 700;
    letter-spacing: -0.5px;
    color: var(--text);
    line-height: 1.2;
  }

  h1 span { color: var(--accent); }

  .subtitle {
    color: var(--muted);
    font-size: 13px;
    margin-top: 8px;
    font-weight: 300;
  }

  .main-layout {
    width: 100%;
    max-width: 1100px;
    display: grid;
    grid-template-columns: 1fr 280px;
    gap: 20px;
    align-items: start;
  }

  .chart-panel {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 28px;
    position: relative;
    overflow: hidden;
  }

  .chart-panel::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 1px;
    background: linear-gradient(90deg, transparent, var(--accent), transparent);
    opacity: 0.5;
  }

  canvas {
    display: block;
    width: 100%;
    cursor: crosshair;
  }

  .sidebar {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .card {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 20px;
    position: relative;
    overflow: hidden;
  }

  .card-title {
    font-family: 'Space Mono', monospace;
    font-size: 9px;
    letter-spacing: 2.5px;
    text-transform: uppercase;
    color: var(--muted);
    margin-bottom: 16px;
  }

  .metric {
    margin-bottom: 14px;
  }

  .metric-label {
    font-size: 11px;
    color: var(--muted);
    margin-bottom: 4px;
    font-weight: 500;
  }

  .metric-value {
    font-family: 'Space Mono', monospace;
    font-size: 20px;
    font-weight: 700;
    line-height: 1;
  }

  .metric-value.cyan { color: var(--accent); }
  .metric-value.red { color: var(--accent2); }
  .metric-value.green { color: var(--accent3); }

  .metric-unit {
    font-size: 12px;
    color: var(--muted);
    font-weight: 400;
    margin-left: 3px;
  }

  /* Improvement bar */
  .improvement-bar-wrap {
    margin-top: 6px;
  }

  .improvement-bar-track {
    height: 4px;
    background: rgba(255,255,255,0.07);
    border-radius: 2px;
    overflow: hidden;
    margin-top: 6px;
  }

  .improvement-bar-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--accent2), var(--accent3));
    border-radius: 2px;
    transition: width 0.4s ease;
  }

  .improvement-label {
    font-size: 11px;
    color: var(--accent3);
    font-family: 'Space Mono', monospace;
    margin-top: 4px;
  }

  /* Controls */
  .control-group { margin-bottom: 14px; }

  .control-label {
    font-size: 11px;
    color: var(--muted);
    margin-bottom: 8px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .control-label span {
    font-family: 'Space Mono', monospace;
    font-size: 11px;
    color: var(--accent);
  }

  input[type="range"] {
    width: 100%;
    -webkit-appearance: none;
    height: 3px;
    border-radius: 2px;
    background: var(--border);
    outline: none;
    cursor: pointer;
  }

  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: var(--accent);
    border: 2px solid var(--bg);
    box-shadow: 0 0 8px rgba(0,212,255,0.5);
    cursor: pointer;
    transition: box-shadow 0.2s;
  }

  input[type="range"]::-webkit-slider-thumb:hover {
    box-shadow: 0 0 14px rgba(0,212,255,0.8);
  }

  .toggle-row {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }

  .toggle-btn {
    font-family: 'Space Mono', monospace;
    font-size: 9px;
    letter-spacing: 1px;
    text-transform: uppercase;
    padding: 5px 10px;
    border-radius: 4px;
    border: 1px solid var(--border);
    background: transparent;
    color: var(--muted);
    cursor: pointer;
    transition: all 0.2s;
  }

  .toggle-btn.active {
    background: rgba(0,212,255,0.1);
    border-color: var(--accent);
    color: var(--accent);
  }

  .toggle-btn:hover:not(.active) {
    border-color: var(--muted);
    color: var(--text);
  }

  /* Cursor info */
  .cursor-info {
    position: absolute;
    pointer-events: none;
    background: rgba(10,14,26,0.92);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 8px 12px;
    font-family: 'Space Mono', monospace;
    font-size: 11px;
    color: var(--text);
    display: none;
    white-space: nowrap;
    backdrop-filter: blur(4px);
    z-index: 10;
    line-height: 1.6;
  }

  .cursor-info.visible { display: block; }

  /* FFT spectrum display */
  .spectrum-wrap {
    margin-top: 12px;
  }

  #fftCanvas {
    width: 100%;
    border-radius: 4px;
    background: rgba(0,0,0,0.2);
    display: block;
  }

  .footer-note {
    font-family: 'Space Mono', monospace;
    font-size: 10px;
    color: var(--muted);
    text-align: center;
    margin-top: 24px;
    letter-spacing: 0.5px;
  }

  @media (max-width: 750px) {
    .main-layout { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>

<header>
  <div class="badge">FFT Signal Processing</div>
  <h1>PSNR vs <span>Filter Cutoff</span> Frequency</h1>
  <p class="subtitle">Interactive analysis — hover chart to explore values · drag slider to adjust cutoff</p>
</header>

<div class="main-layout">

  <!-- Chart Panel -->
  <div class="chart-panel">
    <canvas id="mainChart" height="420"></canvas>
    <div class="cursor-info" id="tooltip"></div>
  </div>

  <!-- Sidebar -->
  <div class="sidebar">

    <!-- Key Metrics -->
    <div class="card">
      <div class="card-title">Key Metrics</div>

      <div class="metric">
        <div class="metric-label">Optimal Cutoff</div>
        <div class="metric-value cyan">45<span class="metric-unit">Hz</span></div>
      </div>

      <div class="metric">
        <div class="metric-label">Best PSNR</div>
        <div class="metric-value green">23.3<span class="metric-unit">dB</span></div>
      </div>

      <div class="metric">
        <div class="metric-label">Noisy PSNR (baseline)</div>
        <div class="metric-value red">17.6<span class="metric-unit">dB</span></div>
      </div>

      <div class="improvement-bar-wrap">
        <div class="metric-label">Improvement over baseline</div>
        <div id="improvementVal" class="improvement-label">+5.7 dB</div>
        <div class="improvement-bar-track">
          <div class="improvement-bar-fill" id="improvBar" style="width:65%"></div>
        </div>
      </div>
    </div>

    <!-- Controls -->
    <div class="card">
      <div class="card-title">Controls</div>

      <div class="control-group">
        <div class="control-label">
          Cutoff Frequency
          <span id="cutoffLabel">45</span>
        </div>
        <input type="range" id="cutoffSlider" min="5" max="115" value="45" step="5">
      </div>

      <div class="control-group">
        <div class="control-label">
          Noise Level (σ)
          <span id="noiseLabel">25</span>
        </div>
        <input type="range" id="noiseSlider" min="5" max="60" value="25" step="5">
      </div>

      <div class="control-group">
        <div class="control-label">Overlay Layers</div>
        <div class="toggle-row">
          <button class="toggle-btn active" data-layer="psnr">PSNR</button>
          <button class="toggle-btn active" data-layer="baseline">Baseline</button>
          <button class="toggle-btn active" data-layer="optimal">Optimal</button>
          <button class="toggle-btn active" data-layer="area">Fill</button>
        </div>
      </div>
    </div>

    <!-- FFT Spectrum Preview -->
    <div class="card">
      <div class="card-title">FFT Spectrum Preview</div>
      <div class="spectrum-wrap">
        <canvas id="fftCanvas" height="80"></canvas>
      </div>
      <div style="font-size:10px;color:var(--muted);margin-top:8px;line-height:1.5;">
        Drag the cutoff slider to see how the low-pass filter attenuates high-frequency noise components.
      </div>
    </div>

  </div>
</div>

<p class="footer-note">PSNR peaks at cutoff = 45 · optimal balance between denoising &amp; detail preservation</p>

<script>
// ─── Data Generation ─────────────────────────────────────────
const NOISY_PSNR = 17.6;

function generatePSNRCurve(noiseSigma) {
  const freqs = [];
  const psnrs = [];
  for (let f = 5; f <= 115; f += 5) {
    freqs.push(f);
    // Model: gaussian-ish peak around (1 - noise/80) * 50
    const optCutoff = 45 * (1 - (noiseSigma - 25) * 0.008);
    const basePSNR = NOISY_PSNR + (10 * Math.log10(625 / (noiseSigma * noiseSigma)));
    const peak = basePSNR + 5.8;
    const width = 38 + noiseSigma * 0.3;
    const psnr = peak - Math.pow((f - optCutoff) / width, 2) * 22;
    psnrs.push(Math.max(NOISY_PSNR - 1.5, psnr));
  }
  return { freqs, psnrs };
}

// ─── State ────────────────────────────────────────────────────
const state = {
  cutoff: 45,
  noise: 25,
  layers: { psnr: true, baseline: true, optimal: true, area: true },
  hover: null
};

// ─── Chart Drawing ────────────────────────────────────────────
const canvas = document.getElementById('mainChart');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');

function setCanvasSize() {
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = (rect.width - 56) * dpr;
  canvas.height = 420 * dpr;
  canvas.style.width = (rect.width - 56) + 'px';
  canvas.style.height = '420px';
  ctx.scale(dpr, dpr);
}

function getPSNRAtCutoff(cutoff, psnrs, freqs) {
  const idx = freqs.findIndex(f => f >= cutoff);
  if (idx < 0) return psnrs[psnrs.length - 1];
  if (idx === 0) return psnrs[0];
  const t = (cutoff - freqs[idx-1]) / (freqs[idx] - freqs[idx-1]);
  return psnrs[idx-1] + t * (psnrs[idx] - psnrs[idx-1]);
}

function draw() {
  const W = canvas.width / (window.devicePixelRatio||1);
  const H = canvas.height / (window.devicePixelRatio||1);
  ctx.clearRect(0, 0, W, H);

  const PAD = { top: 30, right: 30, bottom: 50, left: 62 };
  const gW = W - PAD.left - PAD.right;
  const gH = H - PAD.top - PAD.bottom;

  const { freqs, psnrs } = generatePSNRCurve(state.noise);
  const minF = 5, maxF = 115;
  const minY = 17, maxY = 24.5;

  function fx(f) { return PAD.left + (f - minF) / (maxF - minF) * gW; }
  function fy(y) { return PAD.top + gH - (y - minY) / (maxY - minY) * gH; }

  // Find optimal
  let optIdx = 0;
  psnrs.forEach((p, i) => { if (p > psnrs[optIdx]) optIdx = i; });
  const optF = freqs[optIdx];
  const optP = psnrs[optIdx];
  const noisyP = NOISY_PSNR + (state.noise - 25) * (-0.15);

  // ── Background grid
  ctx.strokeStyle = 'rgba(30,45,74,0.7)';
  ctx.lineWidth = 1;
  for (let y = 17; y <= 24; y += 0.5) {
    ctx.beginPath();
    ctx.moveTo(PAD.left, fy(y));
    ctx.lineTo(PAD.left + gW, fy(y));
    ctx.stroke();
  }
  for (let f = 20; f <= 115; f += 20) {
    ctx.beginPath();
    ctx.moveTo(fx(f), PAD.top);
    ctx.lineTo(fx(f), PAD.top + gH);
    ctx.stroke();
  }

  // ── Area fill
  if (state.layers.area) {
    const grad = ctx.createLinearGradient(0, PAD.top, 0, PAD.top + gH);
    grad.addColorStop(0, 'rgba(0,212,255,0.18)');
    grad.addColorStop(1, 'rgba(0,212,255,0)');
    ctx.beginPath();
    ctx.moveTo(fx(freqs[0]), fy(noisyP));
    freqs.forEach((f, i) => ctx.lineTo(fx(f), fy(psnrs[i])));
    ctx.lineTo(fx(freqs[freqs.length-1]), fy(noisyP));
    ctx.closePath();
    ctx.fillStyle = grad;
    ctx.fill();
  }

  // ── Baseline
  if (state.layers.baseline) {
    ctx.setLineDash([8, 5]);
    ctx.strokeStyle = 'rgba(255,71,87,0.7)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(PAD.left, fy(noisyP));
    ctx.lineTo(PAD.left + gW, fy(noisyP));
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // ── Optimal cutoff line
  if (state.layers.optimal) {
    ctx.setLineDash([6, 4]);
    ctx.strokeStyle = 'rgba(46,213,115,0.7)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(fx(optF), PAD.top);
    ctx.lineTo(fx(optF), PAD.top + gH);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // ── Selected cutoff line
  if (state.cutoff !== optF) {
    ctx.setLineDash([4, 4]);
    ctx.strokeStyle = 'rgba(0,212,255,0.45)';
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(fx(state.cutoff), PAD.top);
    ctx.lineTo(fx(state.cutoff), PAD.top + gH);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // ── PSNR curve
  if (state.layers.psnr) {
    // Glow pass
    ctx.save();
    ctx.shadowColor = 'rgba(0,212,255,0.5)';
    ctx.shadowBlur = 10;
    ctx.strokeStyle = '#00d4ff';
    ctx.lineWidth = 2.5;
    ctx.lineJoin = 'round';
    ctx.beginPath();
    freqs.forEach((f, i) => {
      if (i === 0) ctx.moveTo(fx(f), fy(psnrs[i]));
      else ctx.lineTo(fx(f), fy(psnrs[i]));
    });
    ctx.stroke();
    ctx.restore();

    // Dots
    freqs.forEach((f, i) => {
      ctx.beginPath();
      ctx.arc(fx(f), fy(psnrs[i]), 3, 0, Math.PI * 2);
      ctx.fillStyle = '#00d4ff';
      ctx.fill();
    });
  }

  // ── Optimal star
  if (state.layers.optimal) {
    drawStar(ctx, fx(optF), fy(optP), 5, 10, 4, '#ff4757');
    ctx.shadowColor = 'rgba(255,71,87,0.6)';
    ctx.shadowBlur = 12;
    ctx.fillStyle = '#ff4757';
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // ── Hover crosshair
  if (state.hover !== null) {
    const hf = Math.round(state.hover / 5) * 5;
    const hp = getPSNRAtCutoff(hf, psnrs, freqs);
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 1;
    ctx.setLineDash([3,3]);
    ctx.beginPath();
    ctx.moveTo(fx(hf), PAD.top); ctx.lineTo(fx(hf), PAD.top + gH);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(PAD.left, fy(hp)); ctx.lineTo(PAD.left + gW, fy(hp));
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.beginPath();
    ctx.arc(fx(hf), fy(hp), 5, 0, Math.PI * 2);
    ctx.fillStyle = '#00d4ff';
    ctx.strokeStyle = '#0a0e1a';
    ctx.lineWidth = 2;
    ctx.fill();
    ctx.stroke();
  }

  // ── Axes
  ctx.strokeStyle = 'rgba(90,112,144,0.6)';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(PAD.left, PAD.top);
  ctx.lineTo(PAD.left, PAD.top + gH);
  ctx.lineTo(PAD.left + gW, PAD.top + gH);
  ctx.stroke();

  // Y axis labels
  ctx.fillStyle = '#5a7090';
  ctx.font = '11px "Space Mono", monospace';
  ctx.textAlign = 'right';
  for (let y = 18; y <= 24; y++) {
    ctx.fillText(y, PAD.left - 10, fy(y) + 4);
  }

  // X axis labels
  ctx.textAlign = 'center';
  for (let f = 20; f <= 115; f += 20) {
    ctx.fillText(f, fx(f), PAD.top + gH + 20);
  }

  // Axis titles
  ctx.fillStyle = 'rgba(90,112,144,0.8)';
  ctx.font = '11px "DM Sans", sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Filter Cutoff Frequency', PAD.left + gW / 2, H - 6);

  ctx.save();
  ctx.translate(14, PAD.top + gH / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText('PSNR (dB)', 0, 0);
  ctx.restore();

  // Legend
  const legend = [
    { color: '#00d4ff', dash: false, label: 'PSNR Curve' },
    { color: 'rgba(255,71,87,0.7)', dash: true, label: `Noisy: ${noisyP.toFixed(1)} dB` },
    { color: 'rgba(46,213,115,0.7)', dash: true, label: `Optimal: ${optF}` },
  ];
  let lx = PAD.left + gW - 10;
  legend.reverse().forEach(l => {
    ctx.textAlign = 'right';
    ctx.font = '10px "Space Mono", monospace';
    ctx.fillStyle = l.color;
    ctx.fillText(l.label, lx, PAD.top + 16);
    lx -= ctx.measureText(l.label).width + 20;
  });

  // Update sidebar
  const selectedPSNR = getPSNRAtCutoff(state.cutoff, psnrs, freqs);
  const improvement = selectedPSNR - noisyP;
  document.getElementById('improvementVal').textContent = `+${improvement.toFixed(1)} dB`;
  document.getElementById('improvBar').style.width = Math.min(100, improvement / 7 * 100) + '%';
}

function drawStar(ctx, cx, cy, spikes, outerR, innerR, color) {
  let rot = (Math.PI / 2) * 3, step = Math.PI / spikes;
  ctx.beginPath();
  ctx.moveTo(cx, cy - outerR);
  for (let i = 0; i < spikes; i++) {
    ctx.lineTo(cx + Math.cos(rot) * outerR, cy + Math.sin(rot) * outerR);
    rot += step;
    ctx.lineTo(cx + Math.cos(rot) * innerR, cy + Math.sin(rot) * innerR);
    rot += step;
  }
  ctx.lineTo(cx, cy - outerR);
  ctx.closePath();
  ctx.fillStyle = color;
}

// ─── Tooltip + Hover ─────────────────────────────────────────
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const W = rect.width;
  const PAD_L = 62, PAD_R = 30;
  const gW = W - PAD_L - PAD_R;
  const rawF = ((mx - PAD_L) / gW) * (115 - 5) + 5;
  if (rawF < 5 || rawF > 115) {
    state.hover = null;
    tooltip.classList.remove('visible');
  } else {
    const hf = Math.max(5, Math.min(115, Math.round(rawF / 5) * 5));
    state.hover = hf;
    const { freqs, psnrs } = generatePSNRCurve(state.noise);
    const hp = getPSNRAtCutoff(hf, psnrs, freqs).toFixed(2);
    const noisyP = (NOISY_PSNR + (state.noise - 25) * (-0.15)).toFixed(1);
    const delta = (hp - noisyP).toFixed(2);
    tooltip.innerHTML = `Cutoff: <b style="color:#00d4ff">${hf}</b> &nbsp;|&nbsp; PSNR: <b style="color:#2ed573">${hp} dB</b> &nbsp;|&nbsp; Δ: <b style="color:#ffa502">+${delta} dB</b>`;
    tooltip.classList.add('visible');
    tooltip.style.left = Math.min(e.clientX - rect.left + 14, W - 280) + 'px';
    tooltip.style.top = (e.clientY - rect.top - 36) + 'px';
  }
  draw();
});

canvas.addEventListener('mouseleave', () => {
  state.hover = null;
  tooltip.classList.remove('visible');
  draw();
});

canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const W = rect.width;
  const PAD_L = 62, PAD_R = 30;
  const gW = W - PAD_L - PAD_R;
  const rawF = ((mx - PAD_L) / gW) * (115 - 5) + 5;
  const hf = Math.max(5, Math.min(115, Math.round(rawF / 5) * 5));
  state.cutoff = hf;
  document.getElementById('cutoffSlider').value = hf;
  document.getElementById('cutoffLabel').textContent = hf;
  draw();
  drawFFT();
});

// ─── Controls ────────────────────────────────────────────────
document.getElementById('cutoffSlider').addEventListener('input', (e) => {
  state.cutoff = +e.target.value;
  document.getElementById('cutoffLabel').textContent = state.cutoff;
  draw(); drawFFT();
});

document.getElementById('noiseSlider').addEventListener('input', (e) => {
  state.noise = +e.target.value;
  document.getElementById('noiseLabel').textContent = state.noise;
  draw(); drawFFT();
});

document.querySelectorAll('.toggle-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const layer = btn.dataset.layer;
    state.layers[layer] = !state.layers[layer];
    btn.classList.toggle('active');
    draw();
  });
});

// ─── FFT Spectrum ─────────────────────────────────────────────
const fftCanvas = document.getElementById('fftCanvas');
const fctx = fftCanvas.getContext('2d');

function drawFFT() {
  const dpr = window.devicePixelRatio || 1;
  const W = fftCanvas.parentElement.offsetWidth - 40;
  fftCanvas.width = W * dpr;
  fftCanvas.height = 80 * dpr;
  fftCanvas.style.width = W + 'px';
  fftCanvas.style.height = '80px';
  fctx.scale(dpr, dpr);

  fctx.clearRect(0, 0, W, 80);
  fctx.fillStyle = 'rgba(0,0,0,0.2)';
  fctx.fillRect(0, 0, W, 80);

  const N = W;
  const cutoffFrac = state.cutoff / 120;

  for (let x = 0; x < N; x++) {
    const fx = x / N;
    // Simulated spectrum: 1/f with noise bumps
    const signal = 1 / (1 + fx * 12) * 0.8 + Math.sin(fx * 18) * 0.04 + Math.random() * 0.02;
    const inBand = fx < cutoffFrac;
    const h = signal * 60;

    const grad = fctx.createLinearGradient(0, 80 - h, 0, 80);
    if (inBand) {
      grad.addColorStop(0, 'rgba(0,212,255,0.9)');
      grad.addColorStop(1, 'rgba(0,212,255,0.2)');
    } else {
      grad.addColorStop(0, 'rgba(255,71,87,0.5)');
      grad.addColorStop(1, 'rgba(255,71,87,0.1)');
    }
    fctx.fillStyle = grad;
    fctx.fillRect(x, 80 - h, 1, h);
  }

  // Cutoff line
  const cx = cutoffFrac * N;
  fctx.strokeStyle = 'rgba(46,213,115,0.9)';
  fctx.lineWidth = 2;
  fctx.setLineDash([3, 3]);
  fctx.beginPath();
  fctx.moveTo(cx, 0); fctx.lineTo(cx, 80);
  fctx.stroke();
  fctx.setLineDash([]);

  // Labels
  fctx.fillStyle = 'rgba(46,213,115,0.8)';
  fctx.font = `${9 * dpr}px Space Mono`; // workaround for dpr
  fctx.font = '9px Space Mono';
  fctx.fillText('cutoff', cx + 3, 12);
}

// ─── Init ─────────────────────────────────────────────────────
window.addEventListener('resize', () => {
  setCanvasSize();
  draw();
  drawFFT();
});

setCanvasSize();
draw();
setTimeout(drawFFT, 50);
</script>
</body>
</html>
