<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FFT · ifftshift Visualizer</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;600;700&family=Syne:wght@400;700;800&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #050a0f;
    --surface: #0b1420;
    --surface2: #0f1e30;
    --border: #1a3050;
    --accent: #00d4ff;
    --accent2: #ff4d6d;
    --accent3: #39ff14;
    --text: #c8e0f4;
    --muted: #4a7090;
    --gold: #ffd700;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'JetBrains Mono', monospace;
    min-height: 100vh;
    overflow-x: hidden;
  }
  /* grid background */
  body::before {
    content: '';
    position: fixed; inset: 0;
    background-image:
      linear-gradient(rgba(0,212,255,0.03) 1px, transparent 1px),
      linear-gradient(90deg, rgba(0,212,255,0.03) 1px, transparent 1px);
    background-size: 40px 40px;
    pointer-events: none;
  }

  header {
    padding: 2.5rem 3rem 1.5rem;
    border-bottom: 1px solid var(--border);
    display: flex; align-items: flex-end; gap: 2rem; flex-wrap: wrap;
  }
  .logo { font-family: 'Syne', sans-serif; font-size: 2.2rem; font-weight: 800; line-height: 1; }
  .logo span { color: var(--accent); }
  .subtitle { font-size: 0.75rem; color: var(--muted); letter-spacing: 0.15em; text-transform: uppercase; margin-bottom: 0.2rem; }

  main { padding: 2rem 3rem; max-width: 1400px; margin: 0 auto; }

  /* concept strip */
  .pipeline {
    display: flex; align-items: center; gap: 0; margin-bottom: 2.5rem;
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 12px; overflow: hidden;
  }
  .pipe-step {
    flex: 1; padding: 1.1rem 1rem; text-align: center; position: relative;
    font-size: 0.72rem; color: var(--muted); letter-spacing: 0.05em;
  }
  .pipe-step.active { background: rgba(0,212,255,0.07); color: var(--accent); }
  .pipe-step.danger { background: rgba(255,77,109,0.07); color: var(--accent2); }
  .pipe-step strong { display: block; font-size: 0.85rem; margin-bottom: 0.2rem; font-family: 'Syne', sans-serif; }
  .pipe-arrow { color: var(--muted); font-size: 1.2rem; padding: 0 0.3rem; flex-shrink: 0; }

  /* main grid */
  .vis-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2rem;
    margin-bottom: 2rem;
  }
  @media (max-width: 900px) { .vis-grid { grid-template-columns: 1fr; } main { padding: 1rem; } }

  .panel {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    overflow: hidden;
  }
  .panel-header {
    padding: 1rem 1.4rem;
    border-bottom: 1px solid var(--border);
    display: flex; align-items: center; gap: 0.8rem;
  }
  .badge {
    font-size: 0.65rem; font-weight: 700; letter-spacing: 0.1em;
    padding: 0.2em 0.6em; border-radius: 4px; text-transform: uppercase;
  }
  .badge-correct { background: rgba(57,255,20,0.15); color: var(--accent3); border: 1px solid rgba(57,255,20,0.3); }
  .badge-wrong   { background: rgba(255,77,109,0.15); color: var(--accent2); border: 1px solid rgba(255,77,109,0.3); }
  .panel-title { font-family: 'Syne', sans-serif; font-weight: 700; font-size: 1rem; }

  canvas {
    display: block; width: 100%; image-rendering: pixelated;
  }
  .panel-body { padding: 1.2rem 1.4rem; }
  .code-line {
    background: var(--surface2); border: 1px solid var(--border);
    border-radius: 6px; padding: 0.7rem 1rem;
    font-size: 0.8rem; margin-bottom: 0.8rem; line-height: 1.6;
  }
  .code-line .kw { color: #c586c0; }
  .code-line .fn { color: var(--accent); }
  .code-line .cm { color: var(--muted); }
  .code-line .strike { text-decoration: line-through; color: var(--accent2); opacity: 0.7; }
  .note {
    font-size: 0.72rem; color: var(--muted); line-height: 1.6;
    padding-left: 0.8rem; border-left: 2px solid var(--border);
  }
  .note.bad { border-color: var(--accent2); color: #ff8099; }
  .note.good { border-color: var(--accent3); color: #80ff60; }

  /* diagram section */
  .shift-diagram {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 2rem;
    margin-bottom: 2rem;
  }
  .shift-diagram h3 { font-family: 'Syne', sans-serif; font-size: 1.1rem; margin-bottom: 1.5rem; color: var(--accent); }
  .shift-row { display: flex; align-items: center; gap: 1rem; margin-bottom: 1.2rem; flex-wrap: wrap; }
  .shift-label { font-size: 0.7rem; color: var(--muted); width: 130px; flex-shrink: 0; letter-spacing: 0.05em; }
  .freq-bar {
    display: flex; height: 48px; border-radius: 6px; overflow: hidden;
    flex: 1; min-width: 200px; border: 1px solid var(--border);
    position: relative;
  }
  .freq-cell {
    flex: 1; display: flex; align-items: center; justify-content: center;
    font-size: 0.65rem; font-weight: 600; transition: background 0.4s;
  }
  .center-zero { background: rgba(0,212,255,0.35); color: var(--accent); }
  .pos-freq    { background: rgba(0,212,255,0.12); color: #6ad0e8; }
  .neg-freq    { background: rgba(255,77,109,0.12); color: #e87090; }
  .corner-zero { background: rgba(255,215,0,0.25); color: var(--gold); }
  .arrow-anim { font-size: 1.5rem; color: var(--muted); animation: pulse 1.5s ease-in-out infinite; }
  @keyframes pulse { 0%,100%{opacity:.4} 50%{opacity:1} }

  /* controls */
  .controls {
    display: flex; gap: 1rem; margin-bottom: 2rem; flex-wrap: wrap;
  }
  .btn {
    font-family: 'JetBrains Mono', monospace; font-size: 0.8rem;
    padding: 0.6rem 1.4rem; border-radius: 6px; cursor: pointer;
    border: 1px solid; transition: all 0.2s; letter-spacing: 0.05em;
  }
  .btn-primary { background: rgba(0,212,255,0.1); border-color: var(--accent); color: var(--accent); }
  .btn-primary:hover { background: rgba(0,212,255,0.25); }
  .btn-danger { background: rgba(255,77,109,0.1); border-color: var(--accent2); color: var(--accent2); }
  .btn-danger:hover { background: rgba(255,77,109,0.25); }

  .signal-select {
    background: var(--surface2); border: 1px solid var(--border);
    color: var(--text); font-family: 'JetBrains Mono', monospace;
    font-size: 0.8rem; padding: 0.6rem 1rem; border-radius: 6px;
    cursor: pointer;
  }

  /* 1D section */
  .section-title { font-family: 'Syne', sans-serif; font-size: 1.4rem; font-weight: 700; margin-bottom: 1.2rem; }
  .section-title span { color: var(--accent); }
</style>
</head>
<body>

<header>
  <div>
    <div class="subtitle">FFT Conceptual Visualizer</div>
    <div class="logo">np.fft.<span>ifftshift</span>()</div>
  </div>
  <div style="font-size:0.75rem; color:var(--muted); max-width:420px; line-height:1.6;">
    Move the zero-frequency back to the corners before <code style="color:var(--accent)">ifft</code>.<br>
    Skip it → spatially incorrect result.
  </div>
</header>

<main>

  <!-- pipeline strip -->
  <div class="pipeline">
    <div class="pipe-step active"><strong>fft2(image)</strong>Forward FFT</div>
    <div class="pipe-arrow">→</div>
    <div class="pipe-step active"><strong>fftshift(F)</strong>Zero → Center</div>
    <div class="pipe-arrow">→</div>
    <div class="pipe-step active" style="background:rgba(255,215,0,0.07);color:var(--gold)"><strong>…modify…</strong>Filter / Edit</div>
    <div class="pipe-arrow">→</div>
    <div class="pipe-step active" style="background:rgba(57,255,20,0.07);color:var(--accent3)"><strong>ifftshift(F)</strong>Zero → Corners ✓</div>
    <div class="pipe-arrow">→</div>
    <div class="pipe-step active"><strong>ifft2(F)</strong>Back to Space</div>
  </div>

  <!-- shift diagram -->
  <div class="shift-diagram">
    <h3>How the Frequency Array is Laid Out</h3>

    <div class="shift-row">
      <div class="shift-label">After fft2()<br><span style="color:var(--muted);font-size:0.65rem">raw output</span></div>
      <div class="freq-bar">
        <div class="freq-cell corner-zero">0</div>
        <div class="freq-cell pos-freq">+1</div>
        <div class="freq-cell pos-freq">+2</div>
        <div class="freq-cell neg-freq">−2</div>
        <div class="freq-cell neg-freq">−1</div>
      </div>
      <div style="font-size:0.7rem;color:var(--muted)">zero at <span style="color:var(--gold)">corners</span></div>
    </div>

    <div class="shift-row">
      <div class="shift-label" style="color:var(--muted);font-size:0.65rem;">→ fftshift()</div>
      <div style="font-size:1.4rem; color:var(--muted); animation: pulse 1.5s ease-in-out infinite;">⇓</div>
    </div>

    <div class="shift-row">
      <div class="shift-label">After fftshift()<br><span style="font-size:0.65rem;color:var(--muted)">human-readable</span></div>
      <div class="freq-bar">
        <div class="freq-cell neg-freq">−2</div>
        <div class="freq-cell neg-freq">−1</div>
        <div class="freq-cell center-zero">0</div>
        <div class="freq-cell pos-freq">+1</div>
        <div class="freq-cell pos-freq">+2</div>
      </div>
      <div style="font-size:0.7rem;color:var(--accent)">zero at <span style="color:var(--accent)">center</span></div>
    </div>

    <div class="shift-row">
      <div class="shift-label" style="color:var(--muted);font-size:0.65rem;">→ ifftshift()</div>
      <div style="font-size:1.4rem; color:var(--muted); animation: pulse 1.5s ease-in-out infinite; animation-delay:0.5s">⇓</div>
    </div>

    <div class="shift-row">
      <div class="shift-label">After ifftshift()<br><span style="color:var(--accent3);font-size:0.65rem">↑ do this before ifft</span></div>
      <div class="freq-bar">
        <div class="freq-cell corner-zero">0</div>
        <div class="freq-cell pos-freq">+1</div>
        <div class="freq-cell pos-freq">+2</div>
        <div class="freq-cell neg-freq">−2</div>
        <div class="freq-cell neg-freq">−1</div>
      </div>
      <div style="font-size:0.7rem;color:var(--accent3)">zero back to <span style="color:var(--gold)">corners</span> ✓</div>
    </div>

    <div style="margin-top:1.5rem; padding: 1rem 1.2rem; background: rgba(255,77,109,0.07); border:1px solid rgba(255,77,109,0.25); border-radius:8px; font-size:0.75rem; color:#ff8099; line-height:1.7;">
      ⚠️ <strong>Why it matters:</strong> <code>ifft2</code> expects zero-frequency at the <em>corners</em> (NumPy's convention).
      If you pass the shifted version directly, every frequency bin is misinterpreted → the reconstructed image is spatially wrong (shifted, phase-corrupted).
    </div>
  </div>

  <!-- signal selector + controls -->
  <div style="margin-bottom:1rem; display:flex; align-items:center; gap:1rem; flex-wrap:wrap;">
    <div class="section-title" style="margin-bottom:0">Live Demo — <span>2D Image</span></div>
    <select class="signal-select" id="signalSel">
      <option value="gaussian">Gaussian blob</option>
      <option value="rect">Rect patch</option>
      <option value="rings">Concentric rings</option>
      <option value="checkers">Checkerboard</option>
      <option value="stripes">Diagonal stripes</option>
    </select>
    <button class="btn btn-primary" onclick="render()">↺ Re-render</button>
  </div>

  <!-- canvas panels -->
  <div class="vis-grid">

    <div class="panel">
      <div class="panel-header">
        <div class="badge badge-correct">STEP 1</div>
        <div class="panel-title">Original Image</div>
      </div>
      <canvas id="cOrig" width="300" height="300"></canvas>
      <div class="panel-body">
        <div class="code-line"><span class="cm"># input spatial domain</span><br><span class="kw">img</span> = generate_signal()</div>
        <div class="note good">The ground truth. We should recover this after round-trip FFT → filter → iFFT.</div>
      </div>
    </div>

    <div class="panel">
      <div class="panel-header">
        <div class="badge badge-correct">STEP 2</div>
        <div class="panel-title">FFT Magnitude (after fftshift)</div>
      </div>
      <canvas id="cFFT" width="300" height="300"></canvas>
      <div class="panel-body">
        <div class="code-line">
          F = np.<span class="fn">fft2</span>(img)<br>
          Fs = np.fft.<span class="fn">fftshift</span>(F) <span class="cm"># center DC</span><br>
          display log|Fs|
        </div>
        <div class="note">Zero-frequency (DC) is now at center. Suitable for human inspection and filtering.</div>
      </div>
    </div>

    <div class="panel">
      <div class="panel-header">
        <div class="badge badge-correct">CORRECT ✓</div>
        <div class="panel-title">With ifftshift → ifft2</div>
      </div>
      <canvas id="cCorrect" width="300" height="300"></canvas>
      <div class="panel-body">
        <div class="code-line">
          Fs_back = np.fft.<span class="fn">ifftshift</span>(Fs)<br>
          result  = np.fft.<span class="fn">ifft2</span>(Fs_back).real
        </div>
        <div class="note good">Perfect reconstruction. Zero-freq was returned to corners before iFFT → convention satisfied.</div>
      </div>
    </div>

    <div class="panel">
      <div class="panel-header">
        <div class="badge badge-wrong">WRONG ✗</div>
        <div class="panel-title">Without ifftshift → ifft2</div>
      </div>
      <canvas id="cWrong" width="300" height="300"></canvas>
      <div class="panel-body">
        <div class="code-line">
          <span class="strike">Fs_back = np.fft.ifftshift(Fs)</span><br>
          result  = np.fft.<span class="fn">ifft2</span>(Fs).real <span class="cm"># BUG</span>
        </div>
        <div class="note bad">Spatially incorrect. Each bin is misinterpreted as a different frequency → corrupted reconstruction.</div>
      </div>
    </div>

  </div>

  <!-- 1D strip explanation -->
  <div class="shift-diagram" style="margin-bottom:0">
    <h3>1-D Illustration — Hover to animate</h3>
    <canvas id="c1D" width="800" height="220" style="width:100%;border-radius:8px;cursor:crosshair;"></canvas>
    <div style="display:flex; gap:2rem; margin-top:1rem; flex-wrap:wrap;">
      <div style="display:flex;align-items:center;gap:0.5rem;font-size:0.72rem;color:var(--muted)"><span style="display:inline-block;width:12px;height:12px;border-radius:2px;background:rgba(0,212,255,0.5)"></span>fftshift output (zero center)</div>
      <div style="display:flex;align-items:center;gap:0.5rem;font-size:0.72rem;color:var(--muted)"><span style="display:inline-block;width:12px;height:12px;border-radius:2px;background:rgba(255,215,0,0.5)"></span>ifftshift output (zero corners = correct for ifft)</div>
      <div style="display:flex;align-items:center;gap:0.5rem;font-size:0.72rem;color:var(--muted)"><span style="display:inline-block;width:12px;height:12px;border-radius:2px;background:rgba(255,77,109,0.5)"></span>reconstruction error (skipped ifftshift)</div>
    </div>
  </div>

</main>

<script>
const N = 300;
const n = N;

// ---- signal generators ----
function getSignal(type) {
  const d = new Float32Array(n * n);
  const cx = n/2, cy = n/2;
  for (let y = 0; y < n; y++) for (let x = 0; x < n; x++) {
    let v = 0;
    const dx = x - cx, dy = y - cy;
    const r = Math.sqrt(dx*dx + dy*dy);
    if (type === 'gaussian') {
      v = Math.exp(-(dx*dx + dy*dy) / (2 * (n/8)*(n/8)));
    } else if (type === 'rect') {
      v = (Math.abs(dx) < n/6 && Math.abs(dy) < n/6) ? 1 : 0;
    } else if (type === 'rings') {
      v = Math.cos(r * 0.18) * Math.exp(-r / (n*0.45));
    } else if (type === 'checkers') {
      v = ((Math.floor(x/20) + Math.floor(y/20)) % 2 === 0) ? 1 : 0;
    } else if (type === 'stripes') {
      v = (Math.sin((x+y) * 0.18) + 1) / 2;
    }
    d[y * n + x] = v;
  }
  return d;
}

// ---- minimal 2D DFT (uses 1D FFT per row+col) ----
// Real-only input DFT using Cooley-Tukey
function fft1d(re, im) {
  const N = re.length;
  if (N <= 1) return;
  const hN = N >> 1;
  const eRe = new Float32Array(hN), eIm = new Float32Array(hN);
  const oRe = new Float32Array(hN), oIm = new Float32Array(hN);
  for (let i = 0; i < hN; i++) {
    eRe[i] = re[2*i]; eIm[i] = im[2*i];
    oRe[i] = re[2*i+1]; oIm[i] = im[2*i+1];
  }
  fft1d(eRe, eIm); fft1d(oRe, oIm);
  for (let k = 0; k < hN; k++) {
    const ang = -2 * Math.PI * k / N;
    const cr = Math.cos(ang), ci = Math.sin(ang);
    const tr = cr*oRe[k] - ci*oIm[k];
    const ti = cr*oIm[k] + ci*oRe[k];
    re[k]     = eRe[k] + tr; im[k]     = eIm[k] + ti;
    re[k+hN]  = eRe[k] - tr; im[k+hN]  = eIm[k] - ti;
  }
}

function fft2d(data) {
  // returns {re, im} arrays length n*n
  const re = new Float32Array(n*n), im = new Float32Array(n*n);
  for (let i = 0; i < n*n; i++) re[i] = data[i];
  // rows
  for (let y = 0; y < n; y++) {
    const rr = re.subarray(y*n, y*n+n);
    const ri = im.subarray(y*n, y*n+n);
    fft1d(rr, ri);
  }
  // cols
  const cr = new Float32Array(n), ci = new Float32Array(n);
  for (let x = 0; x < n; x++) {
    for (let y = 0; y < n; y++) { cr[y] = re[y*n+x]; ci[y] = im[y*n+x]; }
    fft1d(cr, ci);
    for (let y = 0; y < n; y++) { re[y*n+x] = cr[y]; im[y*n+x] = ci[y]; }
  }
  return { re, im };
}

function ifft2d(re, im) {
  // conjugate → fft → conjugate → /N^2
  const cRe = new Float32Array(re), cIm = new Float32Array(im);
  for (let i = 0; i < cIm.length; i++) cIm[i] = -cIm[i];
  const {re: oRe, im: oIm} = {re:cRe, im:cIm};
  // rows
  for (let y = 0; y < n; y++) fft1d(oRe.subarray(y*n,y*n+n), oIm.subarray(y*n,y*n+n));
  // cols
  const cr2 = new Float32Array(n), ci2 = new Float32Array(n);
  for (let x = 0; x < n; x++) {
    for (let y = 0; y < n; y++) { cr2[y] = oRe[y*n+x]; ci2[y] = oIm[y*n+x]; }
    fft1d(cr2, ci2);
    for (let y = 0; y < n; y++) { oRe[y*n+x] = cr2[y]; oIm[y*n+x] = ci2[y]; }
  }
  const N2 = n * n;
  for (let i = 0; i < N2; i++) { oRe[i] = oRe[i] / N2; oIm[i] = -oIm[i] / N2; }
  return oRe;
}

// fftshift on 2D: swap quadrants
function fftshift2d(re, im) {
  const sRe = new Float32Array(n*n), sIm = new Float32Array(n*n);
  const h = n >> 1;
  for (let y = 0; y < n; y++) for (let x = 0; x < n; x++) {
    const sy = (y + h) % n, sx = (x + h) % n;
    sRe[sy*n+sx] = re[y*n+x];
    sIm[sy*n+sx] = im[y*n+x];
  }
  return { re: sRe, im: sIm };
}
// ifftshift: same as fftshift for even N; for odd N differs, but keep consistent
function ifftshift2d(re, im) {
  // inverse: shift by ceil(N/2)
  const sRe = new Float32Array(n*n), sIm = new Float32Array(n*n);
  const h = Math.ceil(n/2);
  for (let y = 0; y < n; y++) for (let x = 0; x < n; x++) {
    const sy = (y + h) % n, sx = (x + h) % n;
    sRe[sy*n+sx] = re[y*n+x];
    sIm[sy*n+sx] = im[y*n+x];
  }
  return { re: sRe, im: sIm };
}

// ---- draw helpers ----
function drawGray(canvas, data, autoScale=true) {
  const ctx = canvas.getContext('2d');
  const img = ctx.createImageData(n, n);
  let mn = Infinity, mx = -Infinity;
  if (autoScale) { for (let v of data) { if(v<mn) mn=v; if(v>mx) mx=v; } } else { mn=0; mx=1; }
  const rng = mx - mn || 1;
  for (let i = 0; i < n*n; i++) {
    const g = Math.min(255, Math.max(0, ((data[i]-mn)/rng)*255));
    img.data[i*4] = g; img.data[i*4+1] = g; img.data[i*4+2] = g; img.data[i*4+3] = 255;
  }
  ctx.putImageData(img, 0, 0);
}

function drawLogMag(canvas, re, im) {
  const ctx = canvas.getContext('2d');
  const img = ctx.createImageData(n, n);
  const mag = new Float32Array(n*n);
  for (let i = 0; i < n*n; i++) mag[i] = Math.log(1 + Math.sqrt(re[i]*re[i]+im[i]*im[i]));
  let mx = 0; for (let v of mag) if(v>mx) mx=v;
  // colormap: dark blue → cyan
  for (let i = 0; i < n*n; i++) {
    const t = mag[i] / mx;
    img.data[i*4]   = Math.round(t * 30);
    img.data[i*4+1] = Math.round(t * 200);
    img.data[i*4+2] = Math.round(50 + t * 200);
    img.data[i*4+3] = 255;
  }
  ctx.putImageData(img, 0, 0);
}

function drawDiff(canvas, a, b) {
  const ctx = canvas.getContext('2d');
  const img = ctx.createImageData(n, n);
  let mx = 0;
  for (let i = 0; i < n*n; i++) { const d=Math.abs(a[i]-b[i]); if(d>mx) mx=d; }
  if (mx < 1e-6) mx = 1;
  for (let i = 0; i < n*n; i++) {
    const t = Math.abs(a[i]-b[i]) / mx;
    img.data[i*4]   = Math.round(255 * t);
    img.data[i*4+1] = Math.round(50 * (1-t));
    img.data[i*4+2] = Math.round(80 * (1-t));
    img.data[i*4+3] = 255;
  }
  ctx.putImageData(img, 0, 0);
}

function render() {
  const type = document.getElementById('signalSel').value;
  const sig = getSignal(type);

  // draw original
  drawGray(document.getElementById('cOrig'), sig, true);

  // fft
  const {re, im} = fft2d(sig);

  // shifted for display
  const {re: sre, im: sim} = fftshift2d(re, im);
  drawLogMag(document.getElementById('cFFT'), sre, sim);

  // correct: ifftshift then ifft
  const {re: ire, im: iim} = ifftshift2d(sre, sim);
  const correct = ifft2d(ire.slice(), iim.slice());
  drawGray(document.getElementById('cCorrect'), correct, true);

  // wrong: skip ifftshift, pass shifted directly
  const wrong = ifft2d(sre.slice(), sim.slice());
  drawGray(document.getElementById('cWrong'), wrong, true);

  draw1D(sig);
}

// ---- 1D illustration ----
function draw1D(sig2d) {
  // take center row
  const row = new Float32Array(n);
  for (let x=0;x<n;x++) row[x] = sig2d[(n>>1)*n + x];

  // simple 1d fft
  const re = row.slice(), im = new Float32Array(n);
  fft1d(re, im);

  // fftshift 1d
  const sRe = new Float32Array(n), sIm = new Float32Array(n);
  const h = n>>1;
  for (let i=0;i<n;i++) { sRe[(i+h)%n] = re[i]; sIm[(i+h)%n] = im[i]; }

  // ifftshift 1d
  const h2 = Math.ceil(n/2);
  const iRe = new Float32Array(n), iIm = new Float32Array(n);
  for (let i=0;i<n;i++) { iRe[(i+h2)%n] = sRe[i]; iIm[(i+h2)%n] = sIm[i]; }

  // mag arrays
  function mag1d(r, m) { return Array.from({length:n}, (_,i)=>Math.log(1+Math.sqrt(r[i]*r[i]+m[i]*m[i]))); }
  const magShifted = mag1d(sRe, sIm);
  const magIfftShifted = mag1d(iRe, iIm);

  const canvas = document.getElementById('c1D');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0,0,W,H);

  // draw three rows
  const rowH = 60, pad = 20, barW = (W - pad*2) / n;

  const maxS = Math.max(...magShifted);
  const maxI = Math.max(...magIfftShifted);

  function drawBar(arr, yOff, color, maxV) {
    for (let i=0;i<n;i++) {
      const bh = (arr[i]/maxV) * (rowH - 4);
      ctx.fillStyle = color;
      ctx.fillRect(pad + i*barW, yOff + rowH - bh, barW, bh);
    }
    // zero line
    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
    ctx.beginPath(); ctx.moveTo(pad, yOff+rowH); ctx.lineTo(W-pad, yOff+rowH); ctx.stroke();
    // DC marker
    const dcX = pad + (n/2)*barW;
    ctx.strokeStyle = 'rgba(0,212,255,0.4)'; ctx.setLineDash([3,3]);
    ctx.beginPath(); ctx.moveTo(dcX, yOff-5); ctx.lineTo(dcX, yOff+rowH+5); ctx.stroke();
    ctx.setLineDash([]);
  }

  // label
  function label(text, y, col) {
    ctx.fillStyle = col; ctx.font = '11px JetBrains Mono';
    ctx.fillText(text, pad, y);
  }

  const y0 = 10, y1 = 85, y2 = 160;

  label('fftshift output  (DC at center — for viewing)', y0+12, 'rgba(0,212,255,0.8)');
  drawBar(magShifted, y0+16, 'rgba(0,212,255,0.4)', maxS);

  label('ifftshift output (DC at corners — correct for ifft2)', y1+12, 'rgba(255,215,0,0.9)');
  drawBar(magIfftShifted, y1+16, 'rgba(255,215,0,0.4)', maxI);

  // error: difference bar
  label('skip ifftshift error  (absolute bin mismatch)', y2+12, 'rgba(255,77,109,0.9)');
  // compute "error" as |shifted - ifftshifted|
  const err = magShifted.map((v,i) => Math.abs(v - magIfftShifted[i]));
  const maxE = Math.max(...err) || 1;
  drawBar(err, y2+16, 'rgba(255,77,109,0.45)', maxE);
}

render();

// re-render on select
document.getElementById('signalSel').addEventListener('change', render);
</script>
</body>
</html>
